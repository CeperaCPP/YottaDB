1 BREAK
  Break Command
   The BREAK command pauses  execution  of  the  code  and  initiates  Direct
   Mode.

   The format of the BREAK command is:

   B[REAK][:tvexpr] [expr[:tvexpr][,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional expression contains a fragment of MUMPS code  to  XECUTE
        before the process enters Direct Mode

   o    The BREAK command without an argument causes  a  pause  in  execution
        of the routine code and immediately initiates Direct  Mode;  in  this
        case, at least two (2) spaces must follow the BREAK  to  separate  it
        from the next command on the line

   o    The  optional  truth-valued  expression  immediately  following   the
        expression is the  argument  postconditional  that  controls  whether
        GT.M  XECUTEs  the  argument;  if  present  and  true,  the   process
        executes the  code  before  entering  Direct  Mode,  if  present  and
        false, the process does not execute the code before  entering  Direct
        Mode

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more BREAK arguments form a legal argument for a BREAK

   Generally,  programs  in  production  must  not  include  BREAK  commands.
   Therefore, GT.M provides the  ZBREAK  and  ZSTEP  commands,  which  insert
   temporary breakpoints in the image rather than  the  source  code.  BREAKs
   inserted with ZBREAK only  exist  until  the  image  terminates  or  until
   explicitly  removed  by  another  ZBREAK  command.  ZSTEP   also   inserts
   temporary BREAKs in the image that only exist for  the  execution  of  the
   ZSTEP command. In the  GT.M  debugging  environment,  ZBREAKs  and  ZSTEPs
   that insert BREAKs provide a more  flexible  and  less  error-prone  means
   of setting breakpoints than coding BREAKs directly  into  a  routine.  For
   more  information  on  ZBREAK  and  ZSTEP,  refer  to  the  sections  that
   describe those commands.

   To  resume  execution  of  the  interrupted  program,  use  the  ZCONTINUE
   command.

   GT.M displays messages identifying the source of a BREAK as:

   o    The body of a program

   o    A ZBREAK action

   o    A device EXCEPTION

   o    A ZSTEP action

   o    A $ZTRAP action

   VIEW "BREAKMSG":mask  selectively  enables  or  disables  these  messages.
   See the section on "VIEW" for an explanation  of  the  mask.  By  default,
   a process executing a GT.M image displays all BREAK messages.

   When a process  encounters  a  BREAK,  it  displays  a  prompt  indicating
   readiness to process commands in Direct Mode.    By  default  Direct  Mode
   displays  the  prompt  GTM>.  SETting  the  $ZPROMPT   intrinsic   special
   variable alters the prompt.

2 Examples
  BREAK Examples

   Example

   LOOP0  F  S act=$O(^act(act)) Q:act=""  B:debug  D LOOP1

   This FOR loop contains a BREAK with a command postconditional.

   Example

   B:$D(x) "W !,""OK""":x,"W !,""Wrong again""":'x

   This uses a BREAK  with  both  command  and  argument  postconditionals.
   The actions in this case display debugging messages.

1 CLOSE
  C[LOSE]
   The  CLOSE  command  breaks  the  connection  between  a  process  and   a
   device.

   The format of the CLOSE command is:

   C[LOSE][:tvexpr] expr[:(keyword[=expr][:...])][,...]

   o   The  optional  truth-valued  expression  immediately   following   the
       command is a  command  postconditional  which  controls  whether  GT.M
       executes the command or not

   o   The required expression specifies the device to CLOSE

   o   The optional keywords specify deviceparameters  which  control  device
       behavior; some deviceparameters take arguments

   o   If  there  is  only  one  keyword,  the  surrounding  parentheses  are
       optional

   o   An indirection operator and an expression atom evaluating  to  a  list
       of one or more CLOSE arguments form a legal argument for a CLOSE

   Upon a  CLOSE,  GT.M  flushes  all  pending  output  to  the  device,  and
   processes any deviceparameters.  CLOSEing  a  device  not  currently  OPEN
   has no effect.

   If  the  device  is  a  sequential  file,  characteristics  controlled  by
   deviceparameters  are   lost   after   the   CLOSE.   GT.M   retains   the
   characteristics  of  all  other  device  types  for   use   in   case   of
   subsequent re-OPENs.

   If the device being CLOSEd  is  $IO,  MUMPS  implicitly  USEs  $PRINCIPAL.
   GT.M ignores CLOSE $PRINCIPAL.

2 Examples
  CLOSE Examples

   Example

   CLOSE mt:REWIND

   This CLOSEs the device, and if  it  is  a  magnetic  tape,  REWINDs  the
   tape.

2 DELETE
  DELETE
   Instructs GT.M to delete the current version  of  the  disk  file  after
   GT.M closes it.

2 EXCEPTION
  EXCEPTION=expr
   Defines an  error  handler  for  an  I/O  device.  The  expression  must
   contain a  fragment  of  MUMPS  code  (e.g.,  GOTO  ERRTAPE)  that  GT.M
   XECUTEs when the driver for the device detects an error.

   For more  information  on  error  handling,  refer  to  the  "Processing
   Errors" chapter in the GT.M Programmer's Guide.

2 GROUP
  GROUP
   Specifies  permission  on  UNIX  files.  The  expression   is   a   mask
   evaluating  to  null  or  to  any  combination  of  the   letters   RWX,
   indicating respectively  Read,  Write,  and  eXecute  access.  When  any
   one of these deviceparameters appears on  a  CLOSE,  any  user  category
   that is not explicitly specified is unchanged.

   In order to  modify  file  security,  the  user  who  issues  the  CLOSE
   must have ownership.

   By default, CLOSE  does  not  modify  the  permissions  on  an  existing
   file.

2 OWNER
  OWNER
   Specifies  User  access  on  UNIX  files.  The  expression  is  a   mask
   evaluating  to  null  or  to  any  combination  of  the   letters   RWX,
   indicating respectively  Read,  Write,  and  eXecute  access.  When  any
   one of these deviceparameters appears on  a  CLOSE,  any  user  category
   that is not explicitly specified is unchanged.

   In order to  modify  file  security,  the  user  who  issues  the  CLOSE
   must have ownership.

   By default, CLOSE  does  not  modify  the  permissions  on  an  existing
   file.

2 RENAME
  RENAME=expr
   Changes the file name to the name  contained  in  the  argument  string.
   When  the  expression  omits  part  of  the  file  specification,   GT.M
   constructs  the  full  file  specification  by  applying  the   defaults
   discussed in the section on device specifications.

   If the process has sufficient access,  it  may  use  RENAME  to  specify
   a different directory as  well  as  file  name.  RENAME  cannot  move  a
   file to a different device.

2 REWIND
  REWIND
   REWIND positions tapes at the BOT marker.

   By default, CLOSE does not REWIND.

2 SYSTEM
  SYSTEM
   Specifies  permission  on  UNIX  files.  The  expression   is   a   mask
   evaluating  to  null  or  to  any  combination  of  the   letters   RWX,
   indicating respectively  Read,  Write,  and  eXecute  access.  When  any
   one of these deviceparameters appears on  a  CLOSE,  any  user  category
   that is not explicitly specified is unchanged.

   In order to  modify  file  security,  the  user  who  issues  the  CLOSE
   must have ownership.

   By default, CLOSE  does  not  modify  the  permissions  on  an  existing
   file.

2 UIC
  UIC=expr
   Establishes the group number for the file.

2 WORLD
  WORLD
   Specifies  User  access  on  UNIX  files.  The  expression  is  a   mask
   evaluating  to  null  or  to  any  combination  of  the   letters   RWX,
   indicating respectively  Read,  Write,  and  eXecute  access.  When  any
   one of these deviceparameters appears on  a  CLOSE,  any  user  category
   that is not explicitly specified is unchanged.

   In order to  modify  file  security,  the  user  who  issues  the  CLOSE
   must have ownership.

   By default, CLOSE  does  not  modify  the  permissions  on  an  existing
   file.


1 DO
  Do Command
   The DO command makes an entry in the MUMPS  virtual  stack  and  transfers
   execution to the location specified by the entryref.

   The format of the DO command is:

   D[O][:tvexpr] [entryref[(expr|.lname[,...])][:tvexpr][,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional entryref specifies a  location  (with  some  combination
        of label,  offset  and  routinename)  at  which  execution  continues
        immediately following the DO

   o    A DO command without an argument (that is a DO followed  by  two  (2)
        spaces) transfers execution to the next line in the routine  if  that
        line contains a number of periods (.) after the  optional  label  and
        before the required linestart; these  periods  indicate  the  current
        level of "immediate" nesting  caused  by  argumentless  DOs;  if  the
        line following the DO contains too many  periods,  MUMPS  reports  an
        error; if the line following the DO contains too few  periods,  MUMPS
        ignores the DO command

   o    A DO command without an argument stacks the current value  of  $TEST,
        in contrast to a DO with an argument,  which  does  not  protect  the
        current value of $TEST

   o    The optional parameter  list  enclosed  in  parentheses  ()  contains
        parameters to pass to the routine entry point

   o    If the DO specifies a parameter  list,  the  entryref  location  must
        start with a label  and  an  argument  list,  i.e.,  MUMPS  prohibits
        entryrefs with offsets during parameter passing

   o    If an element  in  the  parameter  list  starts  with  a  period,  it
        specifies an unsubscripted local variable  name  and  the  DO  passes
        that variable by  reference;  otherwise,  the  element  specifies  an
        expression which the DO evaluates and passes as a value

   o    The optional truth-valued expression following  the  parameter  list,
        or entryref if the argument contains  no  parameter  list,  specifies
        the argument postconditional and controls  whether  GT.M  performs  a
        DO with that argument

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more DO arguments form a legal argument for a DO

   An explicit or  implicit  QUIT  within  the  scope  of  the  DO,  but  not
   within the scope of any  other  DO,  FOR,  XECUTE  or  extrinsic,  returns
   execution to the instruction  following  the  calling  point.  This  point
   may be the next DO argument or a new command. At  the  end  of  a  routine
   or the end of a  nesting  level  created  by  an  argumentless  DO,  MUMPS
   performs an implicit QUIT. Note that any line  that  reduces  the  current
   level of nesting by changing the number  of  leading  periods  (.)  causes
   an implicit QUIT, even if that line contains only a comment.

   Terminating the image is  the  only  way  to  avoid  eventually  returning
   execution  to  the  calling  point.  A  DO  command  may  optionally  pass
   parameters to the invoked subroutine.

   For more information about  entryrefs  and  parameter  passing,  refer  to
   the "General Features" chapter in the GT.M Programmer's Guide.

2 Examples
  DO Examples

   Example

   GTM> DO ^%RD

   This  invokes  the  routine  directory  utility   program   (%RD)   from
   Direct Mode. The ^ specifies that the  DO  invoke  %RD  as  an  external
   routine.

   Example

   GTM> DO A(3)

   This invokes the subroutine at label A and  passes  the  value  3  as  a
   parameter. Because the DO argument has  no  ^,  it  identifies  A  as  a
   label in the current routine.

   Example:

          SET di="" U outfile
          F  S di=$O(^div(di)) Q:di=""  D PREP D  D POST
          .S de="",(nr,gr)=0
          .W "Division ",di,! F  S de=$O(^de(di,de)) Q:de=""  D
          ..W    "Department    ",de,"    Gross    Rev:    ",^grev(di,de),!
          ..W    "Department    ",de,"    Net     Rev:     ",^nrev(di,de),!
          ..S                          gr=gr+^grev(di,de),nr=nr+nrev(di,de)
          .W  "Division  Gross  Rev:  ",gr,!,"Division  Net   Rev:   ",nr,!
          D PRINT^OUTPUT(outfile)
          Q

   This routine first uses  a  DO  with  a  label  argument  (PREP)  to  do
   some  pre-processing.  It  then  uses  an  argumentless   DO   to   loop
   through each division of a company,  formatting  a  report.  Within  the
   first  argumentless  DO,  a  second  argumentless  DO  (line  4)   loops
   through and  formats  each  department  within  a  division.  After  the
   processing  of  all  departments,   control   returns   to   the   first
   argumentless DO, which prints  a  summary  of  the  division.  Following
   processing of all divisions, a DO with  a  label  argument  (POST)  does
   some  post-processing.  Finally,   at   the   next-to-last   line,   the
   routine uses a DO that invokes  a  subroutine  at  a  label  (PRINT)  in
   an external routine (^OUTPUT), passing the  output  file  outfile  as  a
   parameter.

1 ELSE
  Else Command
   MUMPS executes the remainder of the line after the  ELSE  if  $TEST  is  0
   (FALSE). MUMPS does not execute the  rest  of  the  line  if  $TEST  is  1
   (true).

   The format of the ELSE command is:

   E[LSE]

   o    Because ELSE  is  a  conditional  command,  it  does  not  support  a
        command postconditional

   o    The scope of the ELSE is the remainder of the line

   o    Because the ELSE has no  argument,  at  least  two  (2)  spaces  must
        follow the command to separate it from the next command on  the  line
   

   For  information  about   $TEST,   refer   to   the   "Intrinsic   Special
   Variables"  chapter  in  the  GT.M  Programmer's  Guide.   Because   MUMPS
   stacks $TEST only at the execution of  an  extrinsic  or  an  argumentless
   DO command, any XECUTE or DO with  an  argument  has  the  potential  side
   effect of altering $TEST. Therefore, use ELSE with caution.

   Because the scopes of both the IF and the  ELSE  commands  extend  to  the
   rest of the  MUMPS  line,  placing  an  ELSE  on  the  same  line  as  the
   corresponding IF cannot achieve the desired result.

   ELSE is analogous to  IF  '$TEST,  except  the  later  statement  switches
   $TEST to its complement and ELSE never alters $TEST.

   The scope of an ELSE can be extended with DO or XECUTE commands.

2 Examples
  ELSE Examples

   Example

          IF x=+x SET x=x+y
          ELSE  w !,x

   The IF command  evaluates  the  conditional  expression  x=+x  and  sets
   $TEST. If $TEST=1 (true), MUMPS executes the commands following the
   IF. The ELSE on the  following  line  specifies  an  alternative  action
   to take if the expression is false.

   Example

          IF x=+x DO ^GOFISH
          ELSE  SET x=x"^"_y

   The DO with an  argument  after  the  IF  raises  the  possibility  that
   the  routine  ^GOFISH  changes  the  value  of  $TEST,  thus  making  it
   possible  to  execute  both  the  commands  following  the  IF  and  the
   commands following the ELSE.

   Example

          OPEN dev::0 ELSE  WRITE !,"Device unavailable" QUIT

   This ELSE depends on the result of the  timeout  on  the  OPEN  command.
   If the OPEN succeeds, it sets $TEST to  one  (1)  and  MUMPS  skips  the
   rest of the line after the ELSE.  If  the  OPEN  fails,  it  sets  $TEST
   to zero (0) and MUMPS executes the  remainder  of  the  line  after  the
   ELSE.

1 Features
 MUMPS general features
   MUMPS is a general purpose language with an embedded database system. This
   section of the help file describes the features of the language  that  are
   not covered as commands, functions or intrinsic special variables.

2 Data_types
  Data Types
   MUMPS operates with a  single  basic  data  type:  string.  However,  it
   evaluates data using methods that vary according to context.

   The following sections describe the special evaluation methods.

3 Numeric
  Numeric Expressions
   When MUMPS syntax  specifies  a  numexpr,  MUMPS  evaluates  the  data
   as a sequence  of  ASCII  characters  that  specify  a  number.  MUMPS
   stops  the  evaluation  and  provides  the   result   generated   from
   successfully   evaluated   characters   when   it    encounters    any
   character that is not:

   o  a digit 0-9

   o  a  plus-sign  (+)  or   minus-sign   (-)   and   also   the   first
      character in the string

   o  the first decimal-point (.) in the string

   A numeric evaluation with  a  null  result  provides  a  numeric  zero
   (0).

3 Accuracy
  Numeric Accuracy
   GT.M  provides   18   digits   of   accuracy,   independent   of   the
   placement  of  the  decimal  point,   and   a   numeric   range   from
   10**(-43)  to  (10**47)-1.  Numbers  with  three  digits  or  less  to
   the right of the decimal point are precise.

3 Integers
  Integer Expressions
   When MUMPS syntax specifies  an  intexpr,  MUMPS  evaluates  the  data
   as it would  a  numexpr,  except  that  it  stops  the  evaluation  at
   any decimal-point (.) including the first.

3 Truth-values
  Truth-valued Expressions
   When MUMPS  syntax  specifies  a  tvexpr,  MUMPS  evaluates  the  data
   as  a  numeric.  However,  it  stops  the  evaluation  and  returns  a
   true (1) as soon as it  encounters  a  non-zero  digit,  otherwise  it
   returns  a  false  (0).  In  other  words,  MUMPS  treats  expressions
   that have a non-zero numeric  value  as  true,  and  expressions  that
   have a zero numeric value as  false.  The  sign  and/or  decimal  have
   no effect on the evaluation of a truth-valued expression.

2 Names
  MUMPS Names
   MUMPS  uses  names  for  variables,  for  LOCK  command  arguments,  for
   labels on lines and for routine  names.  MUMPS  names  are  alphanumeric
   and must start with an alphabetic character or a percent-sign (%).

   The percent-sign can only appear as  the  first  character  in  a  name.
   By  convention,  names  starting  with   percent-signs   are   generally
   application-independent or distinguished in some similar way.

   MUMPS  does   not   reserve   any   names.   That   is,   MUMPS   always
   distinguishes  key-words  by  context.  Therefore,   MUMPS   permits   a
   variable  or  a  label  called  SET  even  though  the  language  has  a
   command called SET.

   MUMPS names  are  case  sensitive.  That  is,  MUMPS  treats  ABC,  Abc,
   ABc, AbC aBC and abc as six different names.

   MUMPS does not restrict the length of names in  the  main  body  of  the
   standard.   However   the   portability   section   of   the    standard
   recommends  limiting  names  to  a  maximum  of  eight  (8)  characters.
   GT.M effectively limits  names  to  eight  characters  by  ignoring  any
   characters after the first eight.

2 Variables
  Variables
   MUMPS  does  not  require  predefinition  of  variable  type  or   size.
   MUMPS variables  are  either  local  or  global.  Any  variable  may  be
   unsubscripted or subscripted.

3 Arrays_and_subscripts
  Arrays and Subscripts
   In  MUMPS,  subscripted  variables   identify   elements   in   sparse
   arrays. Sparse arrays are  arrays  in  which  not  all  elements  have
   to  actually  exist.  These  arrays  generally  serve  logical  rather
   than mathematical purposes.

   MUMPS array subscripts are  expressions  and  are  not  restricted  to
   numeric values.

   The format for a MUMPS global or local variable is:

   [^]name[(expr1[,...])]

   o  The optional leading caret (^) designates a global variable

   o  The name specifies a particular array

   o  The  optional  expressions  specify  the  subscripts  and  must  be
      enclosed in parentheses and separated by commas (,)

   The  body  of  the  MUMPS   standard   places   no   restrictions   on
   variable names. However,  the  portability  section  of  the  standard
   does  suggest  limits  on  the  length  of  an  individual   subscript
   expression  and  the  total   length   of   a   variable   name.   The
   measurement for the length of  names  includes  an  allowance  for  an
   overhead of two (2) times the number of subscripts.

3 Collation
  MUMPS Collation Sequence
   MUMPS  collates  all  numeric   subscripts   ahead   of   all   string
   subscripts.  Numeric  subscripts  collate  from   most   negative   to
   most positive in value  order.  String  subscripts  collate  in  ASCII
   sequence.

3 Locals
  Local Variables
   A  local  variable  in  MUMPS  refers  to  a  variable   used   solely
   within the scope of  a  single  process.  Local  variable  names  have
   no leading delimiter.

   MUMPS  makes  a  local  variable  available   to,   and   subject   to
   modification by, all routines  executed  within  a  process  from  the
   time that variable is first SET until  it  is  KILLed,  or  until  the
   process stops executing  MUMPS.  However,  MUMPS  "protects"  a  local
   variable  after  that  variable  appears  as  an  argument  to  a  NEW
   command or after it  appears  as  an  element  in  a  formallist  used
   in parameter  passing.  When  MUMPS  protects  a  local  variable,  it
   saves  a  copy  of  the  variable's  value  and  makes  that  variable
   undefined. MUMPS restores the  variable  to  its  saved  value  during
   execution  of  the  QUIT  that  terminates  the  process  stack  level
   associated  with  the  "protecting"  NEW  or  formallist.   For   more
   information on NEW and  QUIT,  refer  to  the  "Commands"  chapter  in
   the GT.M Programmer's Guide.

   MUMPS  restricts  the   following   uses   of   variables   to   local
   variables:

   o  FOR command control variables

   o  elements within the parentheses of an "exclusive" KILL

   o  A KILL with no arguments removes all current local variables

   o  NEW command arguments

   o  Actualnames used by pass-by-reference parameter passing

3 Globals
  Global Variables
   A  global  variable  in  MUMPS  refers   to   a   variable   that   is
   available  to  all  processes  in  a  particular  environment.  Global
   variable names have a leading caret (^) as a delimiter.

   MUMPS  makes  a  global  variable  available  to,   and   subject   to
   modification  by,  all  routines  executed  within  all  processes  in
   an environment from the time that  variable  is  first  SET  until  it
   is KILLed.

   The portability section  of  the  standard  suggests  restricting  the
   total  length  of  a  global   variable   name   to   127   characters
   (including  an  overhead  of  twice  the  number  of  subscripts)  and
   restricting  the  length  of  any  global  single  variable  subscript
   to 63 characters.

   GT.M  restricts  the  length  of  a  global  variable  name   to   253
   characters (including a  maximum  overhead  of  twice  the  number  of
   subscripts). GT.M  does  not  explicitly  restrict  the  length  of  a
   global subscript.

3 Naked_refs
  Naked References
   MUMPS  accepts  an  abbreviation  of  the  global  name   under   some
   circumstances.  When  the  leading  caret  (^)  immediately   precedes
   the  left  parenthesis  delimiting  subscripts,  the  global  variable
   reference is  called  a  naked  reference.  MUMPS  evaluates  a  naked
   reference  by  prepending  the  last  used   global   variable   name,
   except  for  its  last  subscript,   to   the   list   of   subscripts
   specified by the naked  reference.  The  prepended  portion  is  known
   as the naked indicator. An attempt  to  use  a  naked  reference  when
   the prior global reference does  not  exist,  or  did  not  contain  a
   subscript, generates an error.

   Because MUMPS has only  one  process-wide  naked  indicator  which  it
   maintains  as  a  side  effect  of  every  evaluation  of   a   global
   variable,  use  of  the  naked  reference  requires  an  understanding
   of  MUMPS  execution  sequence.  MUMPS  execution  generally  proceeds
   from  left  to  right  within  a  line,  subject  to   commands   that
   change the flow of  control.  However,  MUMPS  evaluates  the  portion
   of  a  SET  command  argument  to   the   right-hand   side   of   the
   equal-sign  before  the  left-hand  side.   Also,   MUMPS   does   not
   evaluate  any  further  $SELECT()  arguments   within   the   function
   after it encounters a true selection argument.

   In  general,  restricting  the  use  of  naked  references   to   very
   limited  circumstances   prevents   problems   associated   with   the
   naked indicator.

3 Environments
  Global Variable Name Environments
   MUMPS recognizes  an  optional  environment  specification  in  global
   names. The  environment  specification  designates  one  of  some  set
   of alternative database files.

   The syntax for global  variable  names  that  include  an  environment
   specification is:

   ^|expr|name[(subscript[,...])]

   In  GT.M,  the  expression  identifies  the   Global   Directory   for
   mapping the global variable.

   Environment   specifications   permit   easy    access    to    global
   variables  in  alternative  databases,  including  other  "copies"  of
   active   variables    in    the    current    database.    Environment
   specifications  are  sometimes  referred   to   as   extended   global
   syntax or extended value syntax.

   GT.M also allows:

   ^|expr1,expr2|name[(subscript[,...])]

   Where  the  first  expression  identifies  the  Global  Directory  and
   the second expression is accepted but ignored by GT.M.

   To  improve  compatibility  with  some  other  MUMPS  implementations,
   GT.M also accepts  another,  non-standard,  syntax.  In  this  syntax,
   the leading and trailing  up-bar  (|)  are  respectively  replaced  by
   a left  square-bracket  ([)  and  a  right  square-bracket  (]).  This
   syntax also requires expratoms, rather than expressions.

   The formats for this non-standard syntax are:

   ^[expratom1]name[(subscript...)]

   or

   ^[expratom1,expratom2]name[(subscript...)]

   where expratom1 identifies  the  global  directory  and  expratom2  is
   a dummy variable.  Note  that  the  first  set  of  brackets  in  each
   format are part of the syntax.  The  second  set  of  square  brackets
   are part of the meta-language, identifying an optional element.

4 Examples
  Global Name Environment Examples

   Example

   $ GTMGBLDIR=TEST.GLD
   $ EXPORT GTMGBLDIR
   $ GTM
   GTM> WRITE $ZGBLDIR
   TEST.GLD
   GTM> WRITE ^A
   THIS IS ^A IN DATABASE RED
   GTM> WRITE ^|"MUMPS1.GLD"|A
   THIS IS ^A IN DATABASE WHITE
   GTM> WRITE $ZGBLDIR
   TEST.GLD
   GTM> HALT
   $ ECHO $GTMGBLDIR
   TEST.GLD

   The  statement  WRITE  ^|"MUMPS1.GLD"|A  writes  variable  ^A  using
   the  Global  Directory,  MUMPS1.GLD,  but  does   not   change   the
   current Global Directory.

   Example

   GTM> WRITE $ZGBLDIR
   MUMPS1.GLD
   GTM> WRITE ^A
   THIS IS ^A IN DATABASE WHITE
   GTM> WRITE ^|"MUMPS1.GLD"|A
   THIS IS ^A IN DATABASE WHITE

   The  statement  WRITE  ^|"MUMPS1.GLD"|A  is  equivalent   to   WRITE
   ^A.

   Specifying   separate   Global   Directories   does    not    always
   translate to using separate databases.

   Example

   WRITE
   ^|"MUMPS1.GLD"|A,!,^|"MUMPS2.GLD"|A,!,^|"MUMPS3.GLD"|A,!
   THIS IS ^A IN DATABASE WHITE
   THIS IS ^A IN DATABASE BLUE
   THIS IS ^A IN DATABASE WHITE

   In this  case  the  WRITE  does  not  display  ^A  from  three  GT.M
   database  files.  Mapping  specified   by   the   Global   Directory
   Editor  (GDE)  determines  the  database  file  to  which  a  Global
   Directory points.

   This result could have occurred under the following mapping:

   ^|"MUMPS1.GLD"|A   -->REGIONA    -->    SEGMENTA    -->    FILE1.DAT
   ^|"MUMPS2.GLD"|A   -->REGIONA    -->    SEGMENT1    -->    FILE2.DAT
   ^|"MUMPS3.GLD"|A -->REGION3 --> SEGMENT3 --> FILE1.DAT

   For  more  information  on  Global   Directories,   refer   to   the
   "Global  Directory  Editor"  chapter  of  the  GT.M   Administration
   and Operations Guide.

2 Literals
  Literals
   MUMPS has both string and numeric literals.

3 String_literals
  String Literals
   String  literals  are  enclosed  in  quotation-marks  (")   and   must
   only   contain   graphic   characters.   In   other   words,   control
   characters  (ASCII  0-31  and  127)  cannot   appear   in   a   string
   literal.  MUMPS  attempts  to  use   character   text   that   appears
   outside of  quotation-mark  delimiters  according  to  context,  which
   generally means as a local variable name.

   In order to include a  quotation-mark  (")  within  a  string  literal
   use a set of two quotation-marks.

   Example

   GTM> WRITE """"
   "
   GTM>

   The  WRITE  displays  a  single  quotation-mark  because   the   first
   quotation-mark delimits the  beginning  of  the  string  literal,  the
   next two quotation-marks denote  a  single  quote  within  the  string
   and and the  last  quotation-mark  delimits  the  end  of  the  string
   literal.

   In order to  include  control  characters  within  a  string  use  the
   $CHAR function and the concatenation operator.

   Example

   GTM> WRITE "A"_$CHAR(9)_"B"
   A       B
   GTM>

   The WRITE displays an "A" followed by  a  tab  (<HT>)  followed  by  a
   "B" using $CHAR() to introduce the non-graphic character.

3 Numeric_literals
  Numeric Literals
   In  MUMPS   numeric   literals   are   entered   without   surrounding
   delimiters.

   Example

   GTM> WRITE 1
   1
   GTM> WRITE 1.1
   1.1

   These display numeric literals that are integer and decimal.

   MUMPS also  accepts  numeric  literals  in  the  form  of  a  mantissa
   and an exponent  separated  by  a  delimiter  of  "E"  in  upper-case.
   The  mantissa  may  be  an  integer  or  a   decimal   fraction.   The
   integer exponent may have an optional leading minus-sign.

   Example

   GTM> WRITE 8E6
   8000000
   GTM> WRITE 8E-6
   .000008
   GTM>

   The  exponential  numeric  form  may  lead  to  ambiguities   in   the
   meaning  of  subscripts.  Because  numeric  subscripts  collate  ahead
   of  string  subscripts,  the  string  subscript  "01E5"  is  not   the
   same as the numeric subscript 01E5.

2 Expressions
  Expressions
   The following items are legal  MUMPS  expression  atoms.  An  expression
   atom is a component of a MUMPS expression.

   o   local variables

   o   global variables

   o   intrinsic special variables

   o   intrinsic functions

   o   extrinsic functions

   o   extrinsic special variables

   o   numeric literals

   o   string literals

   o   an expression enclosed in parentheses

   o   any of the above preceded by a unary operator

   In  addition,  any  of  these  items  may  be  combined  with  a  binary
   operator and another expression atom.

2 Operators
  Operators
   MUMPS has both unary and binary operators.

3 Precedence
  Precedence
   All unary operations have right to left precedence.

   All   MUMPS   binary   operations   have   strict   left   to    right
   precedence.  This  includes  all  arithmetic,   string   and   logical
   operations.    Hierarchies    of    operations    require     explicit
   establishment  of  precedence  using  parentheses  ().  Although  this
   rule  is  counter-intuitive,  it  is  easy  to  remember  and  has  no
   exceptions.

3 Arithmetic
  Arithmetic Operators
   All arithmetic operators  force  MUMPS  to  evaluate  the  expressions
   to which they apply as numeric. The arithmetic operators are:

   +  as  a  unary  operator  simply  forces  MUMPS   to   evaluate   the
      following  expression  as  numeric;  as  a   binary   operator   it
      causes MUMPS to perform addition

   -  as  a  unary  operator  causes  MUMPS  to  negate   the   following
      expression; as  a  binary  operator  it  causes  MUMPS  to  perform
      subtraction

   *  binary operator for multiplication

   /  binary operator for fractional division

   \  binary operator for integer division

   #  binary operator for modulo,  i.e.,  causes  MUMPS  to  produce  the
      remainder from integer  division  of  the  first  argument  by  the
      second

   Remember that  precedence  is  always  left  to  right  and  that  all
   arithmetic  operators  have  the  same   precedence   as   all   other
   operators.

4 Examples
  Arithmetic Operator Examples

   Example

   GTM> WRITE 1+1
   2
   GTM> WRITE 2-1
   1
   GTM> WRITE 2*2
   4
   GTM> WRITE 4/2
   2
   GTM> WRITE 7\3
   2
   GTM> WRITE 7#3
   1
   GTM>

   This  demonstrates  a  simple  example  of  each  binary   operation
   using numeric literals.

   Example

   GTM> WRITE +"12ABC"
   12
   GTM> WRITE --"-3-4"
   -3
   GTM>

   This  shows  the  unary  plus-sign   (+)   operation   forcing   the
   numeric  evaluation  of  a  string   literal.   The   second   WRITE
   demonstrates   the   unary   minus-sign   (-).   Note   the   second
   minus-sign   within   the   string   literal    does    not    cause
   subtraction,  but  rather,   terminates   the   numeric   evaluation
   with the  result  of  negative  three  (-3).  Each  of  the  leading
   minus-signs  causes  one  negation  and  therefore,  the  result  is
   negative three (-3).

3 Numeric_relational
  Numeric Relational Operators
   MUMPS relational operators  always  generate  a  result  of  true  (1)
   or  false  (0).  All  numeric  relational  operators  force  MUMPS  to
   evaluate  the  expressions  to  which  they  apply  as  numeric.   The
   numeric relational operators are:

   >  binary arithmetic greater than

   <  binary arithmetic less than

   The equal-sign (=)  does  not  force  numeric  evaluation  and  should
   therefore   be   viewed   as   a   string   operator.   However,   the
   equal-sign  between  two  numeric  values  does  in  fact   test   for
   numeric equality.

   Other  numeric  relations   are   formed   using   the   logical   NOT
   operator apostrophe (') as follows:

   '>  not greater than, i.e., less than or equal to

   '<  not less than, i.e., greater than or equal to

   '=  not equal, numeric or string operation

4 Examples
  Numeric Relation Examples

   Example

   GTM> WRITE 1>2
   0
   GTM> WRITE 1<2
   1
   GTM>

   These demonstrate the basic arithmetic relational operations.

   Example

   GTM> WRITE 1'<2
   0
   GTM> WRITE 2'<1
   1
   GTM>

   These   demonstrate   combinations    of    arithmetic    relational
   operators with the logical not operator.

3 Logical
  Logical Operators
   MUMPS logical operators always produce  a  result  that  is  true  (1)
   or false (0). All  logical  operators  force  MUMPS  to  evaluate  the
   expressions  to  which  they  apply  as  truth-valued.   The   logical
   operators are:

   '  unary NOT  operator  negates  current  truth-value;  MUMPS  accepts
      placement of the  NOT  operator  next  to  a  relational  operator,
      e.g., A'=B as meaning '(A=B)

   &  binary AND  operator  produces  a  true  result  only  if  both  of
      the expressions are true

   !  binary OR  operator  produces  a  true  result  if  either  of  the
      expressions is true

   Remember  that  precedence  is  always  left   to   right   and   that
   logical  operators   have   the   same   precedence   as   all   other
   operators.

4 Examples
  Logical Operator Examples

   Example

   GTM> WRITE '0
   1
   GTM> WRITE '1
   0
   GTM> WRITE '5689
   0
   GTM> WRITE '-1
   0
   GTM> WRITE '"ABC"
   1
   GTM>

   These  demonstrate  the  unary  NOT   operation.   Note   that   any
   non-zero  numeric  value  is  true  and  therefore   has   a   false
   negation.

   Example

   GTM> WRITE 0&0
   0
   GTM> WRITE 1&0
   0
   GTM> WRITE 0&1
   0
   GTM> WRITE 1&1
   1
   GTM> WRITE 0!0
   0
   GTM> WRITE 1!0
   1
   GTM> WRITE 0!1
   1
   GTM> WRITE 1!1
   1
   GTM>

   These  demonstrate  all  cases  covered  by   the   binary   logical
   operators.

3 String_ops
  String Operators
   All string operators  force  MUMPS  to  evaluate  the  expressions  to
   which they apply as strings. The string operator is:

   _  binary  operator   causes   MUMPS   to   concatenate   the   second
      expression with the first expression

4 Example
  String Operator Example

   Example

   GTM> WRITE "B"_"A"
   BA
   GTM> WRITE "A"_1
   A1
   GTM>

   These demonstrate MUMPS concatenation.

3 String_relational
  String Relational Operators
   MUMPS relational operators  always  generate  a  result  of  true  (1)
   or  false  (0).  All  string  relational  operators  force  MUMPS   to
   evaluate  the  expressions  to  which  they  apply  as  strings.   The
   string relational operators are:

   =  binary  operator  causes  MUMPS  to   produce   a   true   if   the
      expressions are equal

   [  binary operator causes  MUMPS  to  produce  a  true  if  the  first
      expression contains the  ordered  sequence  of  characters  in  the
      second expression

   ]  binary operator causes  MUMPS  to  produce  a  true  if  the  first
      expression  lexically  follows  the  second   expression   in   the
      ASCII collating sequence

   Note that all  non-null  strings  lexically  follow  the  null  string
   and every string contains the null string.

   Other string relations are  formed  using  the  logical  NOT  operator
   apostrophe (') as follows:

   '[  does not contain

   ']  does not follow, i.e., lexically less than or equal to

   '=  not equal, numeric or string operation

4 Examples
  String Relation Examples

   Example

   GTM> WRITE "A"="B"
   0
   GTM> WRITE "C"="C"
   1
   GTM> WRITE "A"["B"
   0
   GTM> WRITE "ABC"["C"
   1
   GTM> WRITE "A"]"B"
   0
   GTM> WRITE "B"]"A"
   1

   These   demonstrate   the   string   relational   operators    using
   string literals.

   Example

   GTM> WRITE 1=1
   1
   GTM> WRITE 1=2
   0
   GTM> WRITE 1="1"
   1
   GTM> WRITE 1=01
   1
   GTM> WRITE 1="01"
   0
   GTM> WRITE 1=+"01"
   1
   GTM>

   These  examples  illustrate  the  dual  nature  of  the   equal-sign
   operator. Notice  that  if  both  expressions  are  string  or  both
   are  numeric,  the  results  are  straight  forward.  However,  when
   the  expressions   are   mixed   the   native   string   data   type
   prevails.

   Example

   GTM> WRITE "a"'="A"
   1
   GTM> WRITE "FRED"'["RED"
   0
   GTM> WRITE "ABC"']""
   0

   These   demonstrate   combinations   of   the   string    relational
   operators with the NOT operator.

3 Pattern
  Pattern Match Operator
   The pattern match operator (?)  causes  MUMPS  to  return  a  true  if
   the  expression  ahead  of   the   question-mark   (?)   matches   the
   characteristics described  by  the  pattern  following  the  operator.
   The pattern is  not  an  expression.  Patterns  are  made  up  of  two
   elements:

   o  a repetition count

   o  a pattern code or a string literal

   The element following  the  pattern  match  operator  may  consist  of
   an indirection operator followed  by  an  element  that  evaluates  to
   a legitimate pattern

4 Repetition_counts
  Pattern Match Repetition Counts
   The  repetition  count  consists  of   either   a   single   integer
   literal  or  a  period  (.)  delimiter  with  optional  leading  and
   trailing  integer  literals.  A  single  integer  literal  specifies
   an  exact  repetition  count.  The   period   syntax   specifies   a
   range  of  repetitions  where  the  leading  number  is  a   minimum
   and  the  trailing  number  is  a  maximum.  When   the   repetition
   count  is  missing  the  leading  number,  MUMPS  assumes  there  is
   no minimum, i.e.,  a  minimum  of  zero  (0).  When  the  repetition
   count is missing  the  trailing  number,  MUMPS  does  not  place  a
   maximum on the number of repetitions.

4 Codes
  Pattern Match Codes
   The pattern codes are:

   o  A - alphabetic characters upper- or lower-case

   o  C - control characters ASCII 0-31 and 127

   o  E - any character; used to pass all characters in portions
      of the string where the pattern is not restricted

   o  L - lower-case alphabetic characters, ASCII 97-122

   o  N - digits 0-9, ASCII 48-57

   o  P - punctuation, ASCII 32-47, 58-64, 91-96, 123-126

   o  U - upper-case alphabetic characters, ASCII 65-90

   Pattern codes  may  appear  in  upper-  or  lower-case  and  may  be
   replaced with string literals.

4 Example
  Pattern Match Example

   Example

   GTM> WRITE "ABC"?3U
   1
   GTM> WRITE "123-45-6789"?3N1"-"2N1"-"4N
   1

   The  first  WRITE  has  a  simple  one  element  pattern  while  the
   second  has  multiple  elements  including  both  codes  and  string
   literals. All the repetition counts are fixed.

   Example

       I x?.E1C.E W !,"Must not contain a control character" Q

   This uses a pattern match to test for control characters.

2 Postconditionals
  Postconditionals
   MUMPS provides postconditionals  as  a  tool  for  placing  a  condition
   on the execution of a single  command  and,  in  some  cases,  a  single
   command  argument.  A  postconditional   consists   of   a   colon   (:)
   delimiter   followed   by   a   truth-valued   expression.   When    the
   expression   evaluates   to   true,   MUMPS   executes    the    command
   occurrence. When the expression  evaluates  to  false,  MUMPS  does  not
   execute the command occurrence.

3 Command
  Command Postconditionals
   Command  postconditionals  appear  immediately  following  a   command
   and apply to all arguments  for  the  command  when  it  has  multiple
   arguments.  All  commands  except  commands  that  themselves  have  a
   conditional  aspect  accept  a  command  postconditional.  Among   the
   MUMPS standard commands, ELSE, FOR,  and  IF  do  not  accept  command
   postconditionals. All  the  GT.M  command  extensions  accept  command
   postconditionals.

3 Argument
  Argument Postconditionals
   Commands   that   affect   the   flow   of    control    may    accept
   postconditionals   on   individual    command    arguments.    Because
   multiple   arguments   act   as   multiple   commands   this   is    a
   straight-forward  application  of  the  same  principal   as   command
   postconditional.  The  only  MUMPS  standard  commands   that   accept
   argument  postconditionals  are  DO,  GOTO  and   XECUTE.   The   GT.M
   command  extensions  that   accept   argument   postconditionals   are
   BREAK, ZGOTO and ZSYSTEM.

2 Timeouts
  Timeouts
   MUMPS provides timeouts  as  a  tool  to  retain  program  control  over
   commands of indefinite duration. A  timeout  consists  of  a  colon  (:)
   delimiter  on  an  argument,  followed  by   a   numeric      expression
   specifying the number  of  seconds  for  MUMPS  to  attempt  to  execute
   the command. When the  timeout  is  zero  (:0),  MUMPS  makes  a  single
   attempt to complete the command.

   When a command has  a  timeout,  MUMPS  maintains  the  $TEST  intrinsic
   special variable as the command  completes.  If  the  command  completes
   successfully, MUMPS sets  $TEST  to  true  (1).  If  the  command  times
   out before  successful  completion,  MUMPS  sets  $TEST  to  false  (0).
   When a command argument does not  specify  a  timeout,  MUMPS  does  not
   maintain $TEST.

   The following commands accept timeouts:

   o   LOCK

   o   JOB

   o   OPEN

   o   READ

   o   ZALLOCATE

   When  a  READ  times  out,  MUMPS  returns  any  characters  that   have
   arrived between  the  start  of  the  command  and  the  timeout.  MUMPS
   does not produce  any  partial  results  for  any  of  the  other  timed
   commands.

2 Routines
  Routines
   MUMPS routines have a name and consist of  lines  of  code  followed  by
   an  end-of-record  which  is  a  carriage-return,  form-feed  (<CR><FF>)
   sequence. MUMPS separates the  name  of  a  routine  from  the  body  of
   the  routine  with  an   end-of-line   which   is   a   carriage-return,
   line-feed (<CR><LF>) sequence.  GT.M  stores  routine  sources  in  UNIX
   files  and  implicitly  supplies  the  end-of-record   and   end-of-line
   records.

   In MUMPS, a routine has no  particular  impact  on  variable  management
   and may include code  that  is  invoked  at  different  times  and  that
   has no logical intersection.

3 Lines
  Lines
   A line of MUMPS code  consists  of  the  following  elements,  in  the
   order in which they are listed:

   o  An optional label.

   o  A  line-start  delimiter.  The  standard  defines  the   line-start
      delimiter  as  a  space  (<SP>)  character.  In  order  to  enhance
      routine  readability,  GT.M  extends  MUMPS  by  accepting  one  or
      more tab (<HT>) characters as line-start delimiters.

   o  Zero  or  more  level  indicators,  which  are  periods  (.).   The
      level  indicators  show  the  level  of  nesting  for  argumentless
      DO commands: the  more  periods,  the  deeper  the  nesting.  MUMPS
      ignores  lines  that   contain   level   indicators   unless   they
      directly  follow  an  argumentless  DO  command  with  a   matching
      level of nesting.

   o  Zero  or  more  commands  and  their   arguments.   MUMPS   accepts
      multiple commands  on  a  line.  The  argument(s)  of  one  command
      are  separated  from  the   next   command   by   a   command-start
      delimiter, consisting of one or more spaces (<SP>).

   o  A   terminating   end-of-line,   which   is   a    carriage-return,
      line-feed (<CR><LF>) sequence.

   For more information on  the  DO  command,  refer  to  the  "Commands"
   chapter in the GT.M Programmer's Guide.

3 Labels
  Labels
   In  addition  to  labels  that  follow  the  rules  for  MUMPS  names,
   MUMPS accepts labels consisting only of digits.

   Formallists   may   immediately   follow   a   label.   A   formallist
   consists  of  one  or  more  names   enclosed   in   parentheses   ().
   Formallists   identify   local   variables   that   "receive"   passed
   values  in  MUMPS  parameter  passing.  For  more  information,  refer
   to the section on "Parameter Passing" in this chapter.

   A  label  may  also  be  followed  by  a  colon  (:)  delimiter.  Such
   labels  are  treated  as  "local"  labels.  Within  the   routine   in
   which  they  appear,  they  perform  the  same  as  a  label  that  is
   identical except without  the  trailing  colon.  From  other  routines
   they are not  accessible.  Using  local  labels  reduces  object  size
   and linking overhead, for both ZLINK and host linking.

3 Comments
  Comments
   In addition to commands, a  line  may  also  contain  a  comment  that
   starts with a  leading  semi-colon  (;)  delimiter.  The  scope  of  a
   comment  is  the  remainder  of  the  line.  In  other  words,   MUMPS
   ignores anything to the right of the comment delimiter.

2 Entryrefs
  Entryrefs
   MUMPS  entryrefs  provide  a  generalized  target  for  referring  to  a
   line within a routine. An  entryref  may  contain  some  combination  of
   a label, an offset and a routinename,  in  that  order.  The  offset  is
   delimited by a plus-sign (+) and  the  routinename  is  delimited  by  a
   caret (^). When  an  entryref  contains  no  label,  MUMPS  assumes  the
   offset  is  from  the  beginning  of  the  routine.  When  an   entryref
   contains  no  offset,  MUMPS  uses  an  offset  of  zero  (0).  When  an
   entryref  contains  no  routinename,   MUMPS   assumes   the   currently
   executing routine.

   MUMPS permits every element in an  entryref  to  have  the  form  of  an
   indirection  operator  followed  by  an  element  that  evaluates  to  a
   legitimate occurrence  of  that  portion  of  the  entryref.  Note  that
   while  most  commands  and   functions   that   use   entryrefs   permit
   argument  indirection,  MUMPS   does   not   accept   indirection   that
   resolves  to  a  combination  of  label  and  offset   or   offset   and
   routinename.

   Offsets  provide  an  extremely  useful  tool  for  debugging.  However,
   avoid their  use  in  production  code  because  they  generally  induce
   unpleasant maintenance problems.

2 Indirection
  Indirection
   MUMPS  provides  indirection  as  a  means  to   defer   definition   of
   elements of the code until  run-time.  In  effect  indirection  names  a
   variable  that  holds  or  "points"  to  the  element.  The  indirection
   operator is the "at-sign" (@).

3 Argument
  Argument Indirection
   Most commands accept indirection of their entire argument.

   Example

   GTM> SET x="^INDER"
   GTM> DO @x

   This simple example is equivalent to DO ^INDER.

3 Atomic
  Atomic Indirection
   Any expression element or  any  local  or  global  variable  name  may
   be replaced by indirection.

   Example

   GTM> SET x="HOOP",b="x"
   GTM> WRITE a="HULA "__@b
   HULA HOOP
   GTM>

   This uses indirection within a concatenation operation.

3 Entryref
  Entryref Indirection
   Any element of an entryref may be replaced by indirection.

   Example

   GTM> SET lab="START",routine="PROG"
   GTM> DO @lab^@routine

   This example is equivalent to DO START^PROG.

3 Pattern
  Pattern Code Indirection
   A pattern code may be replaced by indirection.

   Example

          FOR      p="1U.20A1"",""1U.20A",5N      IF      x?@p       QUIT
          ELSE  WRITE !,"Incorrect format" QUIT

   This uses pattern code  indirection  to  test  x  for  either  a  name
   or a number.

3 Name
  Name Indirection
   Indirection  may  replace  the  prefix  of  a  subscripted  global  or
   local  variable   name.   This   "name"   indirection   requires   two
   indirection  operators,  a  leading  operator  similar  to  the  other
   forms  of  indirection,  and   a   trailing   operator   marking   the
   transition  to  those   subscripts   that   are   not   specified   by
   indirection.

   Example

   GTM> S from="B",to="^A(15),x=""
   GTM> F  S x=$O(@from@(x)) Q:x=""  S @to@(x)=@from@(x)

   This uses name indirection to copy  the  contents  of  a  level  of  a
   local array  to  a  part  of  a  global  array.  The  example  assumes
   that all existing first level nodes of B have data.

3 Concerns
  Indirection Concerns
   MUMPS  indirection  provides  a  very  powerful  tool   for   allowing
   program  abstraction.  However,  because  indirection  is   frequently
   unnecessary and has some disadvantages, use it with restraint.

   Because  routines  that  use  indirection  in   some   ways   do   not
   contain  adequate  information  for  easy   reading,   such   routines
   tend to be more difficult to debug and maintain.

   In  order  to  improve  run-time  performance,  GT.M  tends  to   move
   work from run-time  to  compile-time.  Indirection  in  effect  forces
   compiler  actions  to  occur  at   run-time,   which   minimizes   the
   benefits of compilation.

   MUMPS  allows  most  forms  of  indirection  to  be  recursive.   This
   makes the  tool  elegantly  general.  However,  in  real  applications
   recursive  indirection  typically  costs  more  than  its   worth   by
   making the code obscure and slow.

   There  are  circumstances  where  indirection  serves   a   worthwhile
   purpose. For  instance,  certain  utility  functions  with  a  general
   nature  may  be  clearly  abstracted  and  coded  using   indirection.
   Because MUMPS has no  "case"  command,  DO  (or  GOTO)  with  argument
   indirection provide a clear and  sound  solution  to  the  problem  of
   providing complex branching.


2 Parameter_passing
  Parameter Passing
   Parameter passing provides a  way  of  explicitly  controlling  some  or
   all of the variable context transferred between MUMPS routines.

   MUMPS uses parameter passing for:

   o   A DO command with parameters

   o   An extrinsic function routine

   Parameter passing is optional on DO commands.

   Parameter  passing  uses  two  argument  lists:  the  actuallist,  which
   specifies the  parameters  that  MUMPS  passes  to  an  invoked  routine
   and the formallist, which  specifies  the  local  variables  to  receive
   or associate with the parameters.

3 Actuallists
  Actuallists
   An  actuallist  specifies  the  parameters   MUMPS   passes   to   the
   invoked routine. The  actuallist  contains  a  list  of  one  or  more
   parameters  enclosed  in  parentheses,  immediately  following  a   DO
   or extrinsic function.

   An actuallist:

   o  Is made up of items separated by commas.

   o  Contains   expressions   and/or   actualnames.   Items    may    be
      missing, that is,  two  commas  may  appear  next  to  each  other,
      with nothing between them.

   o  Must be used in an invocation of a routine with a formallist.

   o  Must not contain undefined variables.

   o  Must not have more  items  than  a  formallist  with  which  it  is
      used.

   o  May contain the same item in more than one position.

   Example

   GTM>D MULT(3,X,.RESULT)

   This  example  illustrates  a  DO  with  parameters.  The   actuallist
   contains:

   o  3 - a numeric literal

   o  X - a local variable

   o  RESULT - an actualname

3 Formallists
  Formallists
   A formallist  specifies  the  variables  MUMPS  uses  to  hold  passed
   values. A formallist  contains  a  list  of  one  or  more  parameters
   enclosed in parentheses, immediately following a label.

   A formallist:

   o  is made up of items separated by commas

   o  contains unsubscripted local variable names

   o  must  be  used  and  only  used  with  a  label  invoked  with   an
      actuallist or an extrinsic

   o  may contain undefined variables

   o  may have more items than an actuallist with which it is used

   o  must not contain the same item in more than one position

   o  must contain  at  least  as  many  items  as  the  actuallist  with
      which it is used

   Example

   MULT(MP,MC,RES)
          SET RES=MP*MC
          Q

   In this example  illustrating  a  simple  parameterized  routine,  the
   formallist contains the items:

   o  MP

   o  MC

   o  RES

   An  example  in  the  section  describing   "Actuallists"   shows   an
   invocation that matches this routine.

3 Operation
  Parameter Passing Operation
   MUMPS  performs  an  implicit  NEW  on  the   formallist   names   and
   replaces the formallist items with the actuallist items.

   MUMPS provides the actuallist  values  to  the  invoked  procedure  by
   giving  each  element  in  the  formallist  the  value  or   reference
   provided  by  the  corresponding  element  in  the  actuallist.  MUMPS
   associates the first name  in  the  formallist  with  the  first  item
   in the  actuallist,  the  second  name  in  the  formallist  with  the
   second item in  the  actuallist  and  so  on.  If  the  actuallist  is
   shorter  than  the  formallist,  MUMPS  ensures  that  the  formallist
   items that have no corresponding value are in effect NEWed.

   If  the  formallist  item   has   no   corresponding   item   in   the
   actuallist (indicated by  two  adjacent  commas  in  the  actuallist),
   that item in the formallist becomes undefined.

   If  the  actuallist  item  is  an  expression  and  the  corresponding
   formallist  variable  is  an  array,  parameter   passing   does   not
   affect the  subscripted  elements  of  the  array.  If  an  actualname
   corresponds  to  a   formallist   variable,   MUMPS   reflects   array
   operations  on  the  formallist  variable,  by   reference,   in   the
   variable specified by the actualname.

   MUMPS treats variables that are not  part  of  the  formallist  as  if
   parameter  passing  did  not  exist,  that  is,   MUMPS   makes   them
   available to the invoked routine.

   MUMPS  initiates  execution  at  the  first  command   of   the   line
   specified by the formallabel.

   A QUIT  command  terminates  execution  of  the  invoked  routine.  At
   the time of the QUIT, MUMPS  restores  the  formallist  items  to  the
   values they had at  the  invocation  of  the  routine.  Note  that  in
   the case where a  variable  name  appears  as  an  actualname  in  the
   actuallist  and  also  as  a   variable   in   the   formallist,   the
   restored value reflects any change made by reference.

   A QUIT from a DO does not take an  argument,  while  a  QUIT  from  an
   extrinsic must have an  argument.  This  represents  one  of  the  two
   major differences between the  DO  command  with  parameters  and  the
   extrinsics. MUMPS returns the  value  of  the  QUIT  command  argument
   as the value of  the  extrinsic  function  or  special  variable.  The
   other difference is that MUMPS stacks $TEST for extrinsics.

   Example

          SET X=30,Z="Hello"
          DO WRTSQR(X)
          ZWRITE
          QUIT
   WRTSQR(Z)
          SET Z=Z*Z
          WRITE Z,!
          Q

   Produces:

   900
   X=30
   Z="Hello"

3 Mechanisms
  Parameter Passing Mechanisms
   MUMPS passes the  actuallist  values  to  the  invoked  routine  using
   two parameter-passing mechanisms:

   o  Call-by-Value - where expressions appear

   o  Call-by-Reference - where actualnames appear

   A  call-by-value  passes  a  copy  of  the  value  of  the  actuallist
   expression  to  the  invoked  routine  by  assigning  the  copy  to  a
   formallist variable. If the  parameter  is  a  variable,  the  invoked
   routine   may   change   that   variable.   However,   because   MUMPS
   constructs  that  variable  to  hold  the   copy,   it   deletes   the
   variable  holding  the  copy  when  the  QUIT   restores   the   prior
   formallist   values.   This   also   means   that   changes   to   the
   actuallist  variable  by  the  invoked  routine  do  not  affect   the
   value of the formallist copy.

   Example

          SET X=30
          DO SQR(X)
          ZWRITE
          Q
   SQR(Z) S Z=Z*Z
          Q

   Produces:

   X=30

   A period followed by  a  name  identifies  an  actualname  and  causes
   a call-by-reference.

   A  call-by-reference  passes  a  pointer  to  the  variable   of   the
   invoked   routine   so   operations   on   the   assigned   formallist
   variable also act  on  the  actuallist  variable.  Changes,  including
   KILLs  to  the  formallist  variable,  immediately   have   the   same
   effect on the  corresponding  actuallist  variable.  This  means  that
   MUMPS  passes  changes  to  formallist  variables   in   the   invoked
   routine  back  to  the  invoking  routine  as  changes  in  actuallist
   variables.

   Example

          SET X=30
          DO SQR(.X)
          ZWRITE
          Q
   SQR(Z) S Z=Z*Z
          Q

   Produces:

   X=900

3 Extensions
  GT.M Parameter Passing Extensions
   The  standard  does  not  address   the   case   where   the   routine
   supplies an indirect label as a subscripted local variable.

   Example

          D @X(1)

   This example could be:

   o  An invocation of the label specified  by  X  with  a  parameter  of
      1

   o  An  invocation  of  the   label   specified   by   X(1)   with   no
      parameter list

   GT.M  processes  the  latter  interpretation  as  illustrated  in  the
   following example.

   Example

   The syntax:

          SET A(1)="CUBE",X=5
          DO @A(1)(.X)
          WRITE X,!
          Q
   CUBE(C) ; cube a variable
          S C=C*C*C
          Q

   Produces the result:

   125

   GT.M follows analogous syntax for routine indirection:

   DO ^@X(A)       invokes the routine specified by X(A)

   DO ^@(X)(A)     invokes the routine specified  by  X  and  passes  the
                   parameter A

   DO ^@X(A)(A)    invokes the  routine  specified  by  X(A)  and  passes
                   the parameter A

2 Extrinsics
 Extrinsics
   MUMPS   provides   Extrinsic    functions    and    special    variables
   allowing  the  user  to  write  programs  that  behave  like   intrinsic
   functions  and  special  variables,   respectively.   Extrinsics   start
   with  a  double  dollar-sign,  while  intrinsics  start  with  a  single
   dollar-sign.   A   function   has   an   argument   list   enclosed   in
   parentheses.  The  functions   argument   list   is   the   only   thing
   differentiating it from a special variable.

3 Functions
  Extrinsic Functions
   An extrinsic  function  is  a  MUMPS  subroutine  that  another  MUMPS
   routine can invoke to return a value.

   The format for extrinsic functions is:

   $$[label][^routinename]([expr|.lname[,...]])

   o   The  optional  label  and  optional  routinename   make   up   the
       formallabel that specifies the name of the  subroutine  performing
       the extrinsic function; the  formallabel  must  contain  at  least
       one of its optional components

   o   the optional expressions and actualnames make  up  the  actuallist
       that specifies the list of actual parameters MUMPS passes  to  the
       invoked routine

   MUMPS stacks $TEST for extrinsic functions. This  represents  the  one
   of the two major differences between the DO  command  with  parameters
   and the extrinsics.  On  return  from  an  extrinsic  function,  MUMPS
   restores the  value  of  $T  to  what  it  was  before  the  extrinsic
   function,  regardless  of  the  actions  executed   by   the   invoked
   routine.

   MUMPS requires that a routine that implements  an  extrinsic  function
   terminate with  an  explicit  QUIT  command  which  has  an  argument.
   MUMPS returns the value of the  QUIT  command  as  the  value  of  the
   extrinsic  function.  This  represents  the  other  major   difference
   between the DO command with parameters and the extrinsics.

4 Example
  Extrinsic Function Example

   Example

   GTM> ZPRINT ^POWER

   POWER(V,X,S,T)      ;   extrinsic    to    raise    to    a    power
          ; ignores fractional powers
          SET T=1,S=0
          IF X<0 SET X=-X,S=1
          FOR X=1:1:X S T=T*V
          QUIT $S(S:1/T,1:T)

   GTM> WRITE $$^POWER(3,4)
   81
   GTM>


3 Special_variables
  Extrinsic Special Variables
   An extrinsic special  variable  is  a  user-written  MUMPS  subroutine
   that another MUMPS routine can invoke to return a value.

   The format for extrinsic special variables is:

   $$[label][^routinename]

   o  The  optional  label  and  optional   routinename   make   up   the
      formallabel,  which  specifies   the   name   of   the   subroutine
      performing   the   extrinsic   function;   the   formallabel   must
      contain at least one of its optional components

   An extrinsic special variable  can  be  thought  of  as  an  extrinsic
   function   without   input   parameters.   $$x   is   equivalent    in
   operation  to  $$x().  MUMPS  stacks  $TEST  for   extrinsic   special
   variables.

   MUMPS  requires  that  a  routine   that   implements   an   extrinsic
   special  variable  terminate  with  an  explicit  QUIT  command  which
   has an argument. MUMPS returns  the  value  of  the  QUIT  command  as
   the value of the extrinsic special variable.

4 Example
  Extrinsic Function Example

   Example

   GTM> ZPRINT ^DAYOWEEK

   DAYOWEEK()  ;extrinsic  special  variable  to  provide  the  day  of
   the week
          QUIT $ZD($H,"DAY")

   GTM> WRITE $$DAYOWEEK^DAYOWEEK
   MON

2 Transaction_processing
  Transaction Processing
   Transaction Processing  (TP)  provides  a  way  for  MUMPS  programs  to
   organize  database  updates  into  logical  groups  that  occur   as   a
   single  event.  That  is,  either  all  the  database   updates   in   a
   transaction occur, or none of them  occur.  Other  processes  never  see
   any intermediate state.

3 Definitions
  TP Definitions
   In MUMPS, a TRANSACTION is  a  sequence  of  commands  beginning  with
   a TSTART command and ending  with  a  TCOMMIT  command,  that  is  not
   within the scope of another TRANSACTION.

   A successful TRANSACTION  ends  with  a  COMMIT,  which  is  triggered
   by the TCOMMIT command  at  the  end  of  the  TRANSACTION.  A  COMMIT
   causes all the  database  updates  performed  within  the  TRANSACTION
   to become available to other processes.

   An  unsuccessful  TRANSACTION  ends  with  a  ROLLBACK.  ROLLBACK   is
   invoked  by  the  TROLLBACK   command   or   implicitly   at   process
   termination,  if  termination  occurs  when  a   TRANSACTION   is   in
   progress.  An  error  within  a  TRANSACTION   does   not   cause   an
   implicit  ROLLBACK.  A   ROLLBACK   removes   any   database   updates
   performed within  the  TRANSACTION  before  they  are  made  available
   to other  processes.  ROLLBACK  also  releases  all  resources  LOCKed
   since the start of the  TRANSACTION  and  makes  the  naked  reference
   undefined.

   A  RESTART  is  a  transfer  of  control  to   the   TSTART   at   the
   beginning  of  the  TRANSACTION.   RESTART   implicitly   includes   a
   ROLLBACK  and  may  optionally  restore   local   variables   to   the
   values they had when  the  initial  TSTART  was  originally  executed.
   A RESTART always  restores  $TEST  and  the  naked  reference  to  the
   values  they  had  when  the  initial  TSTART  was  executed.  RESTART
   does not  manage  device  state  information.  A  RESTART  is  invoked
   by the  TRESTART  command  or  by  MUMPS,  if  MUMPS  determines  that
   the  TRANSACTION  is  in  conflict  with   other   database   updates.
   RESTART  can  only  happen  if  the   initial   TSTART   includes   an
   argument that enables RESTART.

3 Characteristics
  TP Characteristics
   Most   transaction   processing    systems    attempt    to    provide
   transactions that meet  the  "ACID"  test.  ACID  stands  for  Atomic,
   Consistent, Isolated, and  Durable.  Because  of  the  MUMPS  approach
   of  providing  maximum  flexibility  and   providing,   as   much   as
   possible,  backwards  compatibility  with  older   versions   of   the
   standard,  MUMPS  transaction   processing   requires   the   use   of
   programming conventions to meet the ACID test.

   For example, some of the  effects  of  the  OPEN,  USE,  READ,  WRITE,
   CLOSE,  and  JOB  commands  may  be  observed  by   parties   to   the
   system.  Therefore,  because  the  effects  of  these  commands  might
   cause  an  observing  process   or   person   to   conclude   that   a
   TRANSACTION  executing  them  was  in   progress   and   perhaps,   by
   inference, "as good as  done,"  they  violate,  at  least  in  theory,
   the principle of Isolation.

   The LOCK  command  is  another  example.  A  program  may  attempt  to
   use a LOCK to determine  if  another  process  has  a  TRANSACTION  in
   progress. The answer, however,  would  depend  on  the  management  of
   LOCKs   within   TRANSACTIONs,   which   is   implementation-specific.
   This would therefore  clearly  violate  the  principle  of  Isolation.
   The LOCK command is discussed later in this section.

   The simplest way to  construct  a  TRANSACTION  that  meets  the  ACID
   test  is  not  to  use  any  commands  within  a   TRANSACTION   whose
   effects  may  be  immediately  "visible"  outside   the   TRANSACTION.
   Unfortunately,    because    MUMPS     applications     are     highly
   interactive,  this  is  not  entirely  straightforward.  When  a  user
   interaction  relies  on  database  information,   the   program   must
   save in local variables  the  initial  values  of  any  global  values
   that  could  affect  the  outcome.  Then,  once  the  interaction   is
   over and the  TRANSACTION  has  been  initiated,  the  program  checks
   the saved  values  against  the  corresponding  global  variables.  If
   they  are  the  same,  it  proceeds.  If  they  differ,   some   other
   update has changed the information,  and  the  program  must  issue  a
   TROLLBACK and initiate another interaction as a replacement.

   Even when the  "visible"  commands  appear  within  a  TRANSACTION,  a
   MUMPS application  may  provide  wholesome  operation  by  relying  on
   additional programming or operating conventions.

   A  program  using  LOCKs  to   achieve   serializability   relies   on
   properly  designed  and  universally  followed   LOCKing   conventions
   to achieve  Isolation  with  respect  to  database  operations.  LOCKs
   placed  outside  the   TRANSACTION   (usually   a   LOCK   immediately
   before the  TSTART  and  an  unLOCK  immediately  after  the  TCOMMIT)
   achieve    serializability     by     actually     serializing     any
   approximately  concurrent  TRANSACTIONs.  LOCKs   place   inside   the
   TRANSACTION (frequently  a  LOCK  immediately  after  the  TSTART  and
   an unLOCK immediately before  the  TCOMMIT)  signal  MUMPS  to  ensure
   that  no  operations  using  the  same   LOCK   resource(s)   overlap.
   Within  a  TRANSACTION,  a  MUMPS  implementation   may   defer   both
   LOCKing and unLOCKing  to  achieve  its  goal  of  serializability.  A
   program  using  TSTARTs  with  the   SERIAL   keyword   replaces   the
   convention  with  a  guarantee  from  MUMPS  that  all  the   database
   activity  of  the  TRANSACTION  meets  the  test  of  Isolation   with
   respect to database activity.

   Attempting to  QUIT  (implicitly  or  explicitly)  from  code  invoked
   by a DO,  XECUTE,  or  extrinsic  after  that  code  issued  a  TSTART
   not yet matched  by  a  TCOMMIT,  produces  an  error.  Although  this
   is a consequence of the RESTART  capability,  it  is  true  even  when
   that  capability  is  disabled.  For  example,  this  means  that   an
   XECUTE  containing  only  a  TSTART  fails,  while  an   XECUTE   that
   performs a complete TRANSACTION succeeds.

3 Performance
  TP Performance
   To achieve the best performance using GT.M, TRANSACTIONs should:

   o  be as short as possible

   o  consist, as much as possible, only of global updates

   o  be SERIAL with no associated LOCKs

   o  have  RESTART  enabled  with   a   minimum   of   local   variables
      protected by a restart portion of the TSTART argument.

3 Examples
  TP Examples

   TSTART ():SERIAL
   S (ACCT,^M(0))=^M(0)+1
   S ^M(ACCT)=PREC,^PN(NAM)=ACCT
   TCOMMIT

   This TRANSACTION encapsulates  two  SETs.  The  first  increments  the
   tally  of  patients  registered,   storing   the   number   in   local
   variable ACCT  for  faster  access  in  the  transaction  and  current
   program, and in global  variable  ^M(0).  Then  second  SET  stores  a
   patient  record   by   account   number   and   cross-references   the
   account number with the  patient  name.  Placing  the  SETs  within  a
   single TRANSACTION ensures  that  the  database  will  always  receive
   either both  SETs  or  neither,  thus  protecting  database  integrity
   against process  or  system  failure.  Similarly,  another  concurrent
   process, whether using  TRANSACTIONs  or  not,  will  never  find  one
   of the SETs in place without also finding the other one.


   TSTART ():SERIAL
   IF $TRESTART>10 DO  QUIT
   .  TROLLBACK
   .  WRITE !,"Too many RESTARTs"
   .  QUIT
   SET (NEXT,^ID(0))=^ID(0)+1
   SET ^ID(NEXT)=RECORD,^XID(ZIP,NEXT)=""
   TCOMMIT

   This   TRANSACTION   will   automatically   restart   if   it   cannot
   serialize the  SETs  to  the  database,  and  will  terminate  with  a
   TROLLBACK if more than 10 RESTARTs occur. 
1 FOR
  FOR Command
   The FOR command provides a looping mechanism for MUMPS.  A  FOR  does  not
   generate an additional level on the MUMPS virtual stack.

   The format of the FOR command is:

   F[OR][lvn=expr[:numexpr1[:numexpr2]][,expr[:numexpr1[:numexpr2]][,...]
   ]]

   o    Because FOR is a conditional command, it does not support  a  command
        postconditional

   o    The scope of the FOR is the remainder of the line

   o    When the FOR has no argument, at least two  (2)  spaces  must  follow
        the command to separate it from the next command on  the  line;  this
        specifies a loop that the FOR command never stops

   o    The optional local variable name specifies a  loop  control  variable
        delimited by an equal-sign (=); a FOR command has  only  one  control
        variable, even when it has multiple arguments

   o    When initiating the FOR, MUMPS  assigns  the  loop  control  variable
        the value of the expression; when  only  an  initial  value  appears,
        MUMPS executes the remainder of  the  line  once  for  that  argument
        without forcing the control variable to be numeric

   o    If  the  argument  includes   an   increment   and,   optionally,   a
        terminator, MUMPS treats the initial expression as a number

   o    The optional numeric expression after the first colon  (:)  delimiter
        serves as the increment for each  iteration;  the  FOR  command  does
        not increment the control variable on the first iteration

   o    The  optional  numeric  expression  after  the   second   colon   (:)
        delimiter serves as the limiting value for the control variable

   o    If the  increment  is  nonnegative  and  the  initial  value  of  the
        control variable is greater than the limiting value, MUMPS  does  not
        execute the commands on the same  line  following  the  FOR;  if  the
        increment is negative and the initial value of the  control  variable
        is  less  than  the  limiting  value,  MUMPS  does  not  execute  the
        commands on the same line following the FOR

   o    After the first  iteration,  if  the  increment  is  nonnegative  and
        altering the control  variable  by  the  increment  would  cause  the
        control variable to be greater than the limiting  value,  MUMPS  does
        not alter  the  control  variable  and  ceases  execution  under  the
        control of the FOR; if the increment is  negative  and  altering  the
        control variable by the increment would cause  the  control  variable
        to be less  than  the  limiting  value,  MUMPS  does  not  alter  the
        control variable and ceases execution under the control of the FOR

   o    When the FOR has multiple arguments, each affects  the  loop  control
        variable in sequence; for an  argument  to  gain  control,  no  prior
        argument to the FOR can have an increment without a limit

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more FOR arguments form a legal argument to a FOR

   The scope of a FOR can be extended with DO or XECUTE commands.

   MUMPS terminates the execution of a  FOR  when  it  executes  an  explicit
   QUIT or a GOTO (and in GT.M a  ZGOTO)  that  appears  on  the  line  after
   the FOR. FORs with arguments  that  have  increments  without  limits  and
   argumentless FORs can be infinite loops. Such  FORs  must  terminate  with
   a QUIT or a GOTO within  the  immediate  scope  of  the  FOR,  or  a  HALT
   within  the  scope  of  the  FOR  as  extended   by   DOs,   XECUTEs   and
   extrinsics. FORs terminated by such commands act  as  "while"  or  "until"
   control mechanisms.

   Increments  and  limits  may  be  positive   or   negative,   integer   or
   fractional.  MUMPS  never  increments  a  control  variable   "beyond"   a
   limit. Other commands may alter a control  variable  within  the  extended
   scope of a FOR that it controls.  When  the  argument  includes  a  limit,
   such modification can cause the FOR  argument  to  yield  control  at  the
   start of the next iteration.

2 Examples
  FOR Examples

   Example

   GTM> KILL i FOR i=1:1:5 WRITE !,i

   1
   2
   3
   4
   5

   GTM >WRITE i
   5

   GTM>

   This FOR loop has a  control  variable,  i,  which  has  the  value  one
   (1) on the first iteration, then the  value  two  (2),  etc.,  until  on
   the last iteration  i  has  the  value  five  (5).  The  FOR  terminates
   because incrementing i would cause it  to  exceed  the  limit.    Notice
   that i is not incremented beyond the limit.

   Example

   GTM> FOR x="hello",2,"goodbye" WRITE !,x

   hello
   2
   goodbye

   GTM>

   This FOR loop uses the control variable x  and  a  series  of  arguments
   that have no increments or limits.  Notice  that  the  control  variable
   may have a string value.

   Example

   GTM> FOR x="hello":1:-1 WRITE !,x

   GTM> ZWRITE x
   x=0

   GTM>

   Because  the  argument  has  an  increment,  the  FOR  initializes   the
   control  variable,  x,  to  the  numeric  evaluation  of  "hello"   (0).
   Then,  because  the  increment  is  positive  and  the  value   of   the
   control variable (0) is greater than  the  limiting  value  (-1),  MUMPS
   never executes the remainder of the line.

   Example

   GTM> FOR y=-1:-3:-6,y:4:y+10,"end" WRITE !,y

   -1
   -4
   -4
   0
   4
   end

   GTM>

   This FOR uses  two  limited  loop  arguments  and  one  value  argument.
   The first argument initializes y to  minus  one  (-1),  then  increments
   y to minus four (-4). Because another increment  would  cause  y  to  be
   less  than  the  limit  (-6),  the  first  argument  terminates  with  y
   equal to minus four (-4).  The  second  argument  initializes  the  loop
   control variable to  its  current  value  and  establishes  a  limit  of
   six  (6=-4+10).  After  two  iterations,  incrementing  y  again   would
   cause it to be greater than  the  limit  (6),  so  the  second  argument
   terminates with y equal to four (4).  Because  the  final  argument  has
   no increment, the  FOR  sets  y  to  the  value  of  the  argument,  and
   MUMPS executes the commands following the FOR one time.

   Example

   GTM> S x="" F  S x=$O(ar(x)) Q:x=""  W !,x

   This  shows  an  argumentless  FOR  used  to  examine  all  first  level
   subscripts of the local  array  ar.  When  $ORDER  indicates  that  this
   level   contains   no   more   subscripts,    the    QUIT    with    the
   postconditional terminates the loop.

1 Functions
  Intrinsic Functions
   MUMPS Intrinsic Functions start with a single  dollar-sign  ($)  and  have
   one or  more  arguments  enclosed  in  parentheses  ()  and  separated  by
   commas (,). These Functions provide an  expression  result  by  performing
   actions  that  are  impossible  or  difficult  to  perform   using   MUMPS
   commands.

2 $ASCII
  $ASCII()
   The $ASCII function returns the  integer  ASCII  code  for  a  character
   in a string.

   The format for the $ASCII function is:

   $A[SCII](expr[,intexpr])

   o    The expression acts as the source  string  out  of  which  $ASCII()
        draws the character it encodes

   o    The optional integer expression contains the  position  within  the
        expression  of  the  character  that  $ASCII()  encodes;  if   this
        argument is  missing,  $ASCII()  returns  a  result  based  on  the
        first character position

   o    If the explicit or implicit position is  before  the  beginning  or
        after the end of the expression, $ASCII() returns the value: -1

   $ASCII() provides a means of examining non-graphic characters in a
   string.  Used  with  $CHAR(),  $ASCII()  also  provides   a   means   to
   perform   arithmetic   operations   on   the   codes   associated   with
   characters.

3 Examples
  $ASCII() Examples

   Example

   GTM> FOR i=0:1:3 WRITE !,$A("HI",i)
   -1
   72
   73
   -1
   GTM>

   This  loop   displays   the   result   of   $ASCII(),   specifying   a
   character  position  "before"  the  string,   then   the   first   and
   second positions of the string and finally "after" the string.

2 $CHAR
  $CHAR()
   The  $CHAR  function  returns  a  string  of  one  or  more   characters
   corresponding to integer ASCII codes specified in its argument(s).

   The format for the $CHAR function is:

   $C[HAR](intexpr[,...])

   o    The  integer  expression(s)  specify  the  ASCII   codes   of   the
        character(s) $CHAR() returns

   The MUMPS  standard  does  not  restrict  the  number  of  arguments  to
   $CHAR(). However, GT.M does limit the number of arguments to a
   maximum of 254.  $CHAR()  provides  a  means  of  producing  non-graphic
   characters,  as  such  characters  cannot  appear  directly   within   a
   MUMPS string literal.  Used  with  $ASCII(),  $CHAR()  also  provides  a
   means to perform arithmetic operations  on  the  codes  associated  with
   characters.

3 Examples
  $CHAR() Examples

   Example

   GTM> WRITE $CHAR(77,85,77,80,83,7)
   MUMPS
   GTM>

   This  uses  $CHAR()  to  WRITE  the  word   MUMPS   and   "ring"   the
   terminal "bell".

   Example

          SET nam=$E(nam,1,$L(nam)-1)_$C($A(nam,$L(nam))-1)

   This  uses  $CHAR()  and  $ASCII()  to  set  the  variable  nam  to  a
   value that  lexically  immediately  precedes  its  previous  value  in
   the set of strings of the same length as nam.

2 $DATA
  $DATA()
   The $DATA function returns an integer  code  describing  the  nature  of
   a local or global variable.

   The format for the $DATA function is:

   $D[ATA](glvn)

   o    The subscripted or unsubscripted  global  or  local  variable  name
        specifies the target node

   o    If the variable is undefined, $DATA() returns 0

   o    If the variable has a value but  no  descendants,  $DATA()  returns
        1

   o    If the variable has descendants but no value, $DATA() returns 10

   o    If the variable has a value and descendants, $DATA() returns 11

   MUMPS presents  the  matrix  value  as  a  MUMPS  number  and  therefore
   eliminates any leading zero (0).


3 Examples
  $DATA() Examples

   Example

   GTM> KILL    WRITE $DATA(a)
   0
   GTM> SET a(1)=1 WRITE $DATA(a(1))
   1
   GTM> WRITE $DATA(a)
   10
   GTM>SET a=0 WRITE $DATA(a)
   11
   GTM>

   This uses $DATA to display all possible $DATA() results.

   Example

          L ^ACCT(0)
          I '$D(^ACCT(0)) S ^ACCT(0)=0
          S (ACCT,^ACCT(0))=^ACCT(0)+1
          L

   This  uses  $DATA()  to  determine  whether  a  global  node  requires
   initialization.

   Example

          F  S cus=$O(^cus(cus)) Q:cus=""  I $D(^(cus))>1 D WORK

   This  uses  $DATA()  to  determine   whether   a   global   node   has
   descendants and therefore requires additional processing.

2 $EXTRACT
  $EXTRACT()
   The $EXTRACT function returns a sub-string of a given string.

   The format for the $EXTRACT function is:

   $E[XTRACT](expr[,intexpr1[,intexpr2]])

   o    The expression specifies a string  from  which  $EXTRACT()  derives
        a sub-string

   o    The  first  optional  integer  argument  specifies   the   starting
        character position of the sub-string result; if  this  argument  is
        missing,  $EXTRACT()   returns   the   first   character   of   the
        expression

   o    The  second  optional  integer  argument   specifies   the   ending
        character position for the result; if  this  argument  is  missing,
        $EXTRACT() returns at most one character

   o    If the starting  position  is  zero  (0)  or  negative,  $EXTRACT()
        starts at the first position in the expression

   o    If the ending  position  is  beyond  the  end  of  the  expression,
        $EXTRACT() stops with the last character of the expression

   o    If the starting position is  beyond  the  end  of  the  expression,
        $EXTRACT() returns the null string

   $EXTRACT() provides a tool for manipulating strings based on
   character positions.

3 Examples
  $EXTRACT() Examples

   Example

   GTM> FOR i=0:1:3 WRITE !,$EXTRACT("HI",i),"<"
   <
   H<
   I<
   <
   GTM>

   This  loop  displays  the  result   of   $EXTRACT(),   specifying   no
   ending  character  position  and  a   beginning   character   position
   "before" the string, then  the  first  and  second  positions  of  the
   string and finally "after" the string.

   Example

   GTM> FOR i=0:1:3 WRITE !,$E("HI",1,i),"<"
   <
   H<
   HI<
   HI<
   GTM>

   This  loop  displays   the   result   of   $EXTRACT()   specifying   a
   beginning character position  of  one  (1)  and  an  ending  character
   position  "before"   the   string,   then   the   first   and   second
   positions of the string and finally "after" the string.

   Example

   TRIM(x)
          N i,j
          F j=$L(x):-1:0 Q:$E(x,j)'=" "
          F i=1:1:j Q:$E(x,i)'=" "
          Q $E(x,i,j)

   This  extrinsic  function  uses  $EXTRACT()  to   trim   leading   and
   trailing spaces off its argument.

2 $FIND
  $FIND()
   The  $FIND  function  returns  an  integer   character   position   that
   locates the occurrence of a sub-string within a string.

   The format for the $FIND function is:

   $F[IND](expr1,expr2[,intexpr])

   o    The  first  expression  specifies  the  string  in  which   $FIND()
        searches for the sub-string

   o    The second expression specifies the sub-string  for  which  $FIND()
        searches

   o    The optional integer expression identifies  the  starting  position
        for the $FIND()  search;  if  this  argument  is  missing,  $FIND()
        begins its search in the first position of the string

   o    If the starting position is zero (0) or  negative,  $FIND()  begins
        its search in the first position of the first expression

   o    If $FIND() locates the sub-string, it returns  the  position  after
        the last character of the sub-string within the string

   o    If $FIND() does not locate the sub-string, it returns zero (0)

   $FIND() provides a tool for locating characters. The MUMPS
   "contains"  operator  ([)  and  the  two-argument  $LENGTH()  are  other
   tools that provide related functionality.

3 Examples
  $FIND() Examples

   Example

   GTM> WRITE $F("HIFI","I")
   3
   GTM>

   This uses $FIND() to  WRITE  the  position  of  the  first  occurrence
   of the  character  "I".  The  return  (3)  gives  the  position  after
   the "found" sub-string.

   Example

   GTM> WRITE $FIND("HIFI","I",3)
   5
   GTM>

   This uses $FIND()  to  WRITE  the  position  of  the  next  occurrence
   of the character "I" starting in character position three (3).

   Example

   GTM> S t=1 F  S t=$F("BANANA,"AN",t) Q:'t  W !,t
   4
   6
   GTM>

   This uses a loop with  $FIND()  to  locate  all  occurrences  of  "AN"
   in "BANANA".  The  $FIND()  returns  4  and  6  giving  the  positions
   after the two occurrences of "AN".

2 $FNUMBER
  $FNUMBER()
   The  $FNUMBER  function  returns  a  string   containing   a   formatted
   number.

   The format for the $FNUMBER function is:

   $FN[UMBER](numexpr,expr[,intexpr])

   o    The  numeric  expression  specifies  the  number  that   $FNUMBER()
        formats

   o    The expression specifies  zero  or  more  single  character  format
        control codes; if  the  expression  contains  any  character  other
        than the defined codes, $FNUMBER generates a run-time error

   o    The optional integer expression  specifies  the  number  of  digits
        after the decimal point in the result; if  the  numeric  expression
        has  more  digits  than  specified  by  this  argument,  $FNUMBER()
        rounds to obtain the result; if the numeric  expression  has  fewer
        digits than specified by this argument, $FNUMBER()  zero  fills  to
        obtain the result

   $FNUMBER() formats or edits numbers, usually for reporting. For an
   expanded description of the  rounding  performed  by  $FNUMBER(),  refer
   to the section on $JUSTIFY().

3 Codes
  $FNUMBER() Codes

   The formatting codes are:

   +    Forces a "+" on positive values

   -    Suppresses the "-" on negative values

   ,    Inserts  commas  every  third  position  to  the  left   of   the
        decimal within the number

   T    Represents  the  number  with   a   trailing,   rather   than   a
        leading  sign;   positive   numbers   have   a   trailing   space
        unless the expression includes a plus-sign (+)

   P    Represents  negative  values  in  parentheses;   combining   with
        any other code except comma (,) causes a run-time error

   MUMPS  accepts  both  lower-case  and  upper-case  alphabetic   codes.
   The order of the codes does not affect the result.

3 Examples
  $FNUMBER() Examples

   Example

          SET X=-100000,Y=2000
          WRITE      "SUPPRESS      NEGATIVE      SIGN:",?35,$FN(X,"-"),!
          WRITE          "TRAILING           SIGN:",?35,$FNUMBER(X,"T"),!
          WRITE    "NEGATIVE     NUMBERS     IN     ():",?35,$FN(X,"P"),!
          WRITE        "COMMAS        IN        NUMBER:",?35,$FN(X,","),!
          WRITE      "NUMBER      WITH      FRACTION:",?35,$FN(X,"+",2),!
          WRITE "FORCE + SIGN IF POSITIVE:",?35,$FN(Y,"+"),!

   Produces the results:

   SUPPRESS NEGATIVE SIGN:           100000
   TRAILING SIGN:                    100000-
   NEGATIVE NUMBERS IN ():           (100000)
   COMMAS IN NUMBER:                 -100,000
   NUMBER WITH FRACTION:             -100000.00
   FORCE + SIGN IF POSITIVE:         +2000


   Example

          SET x=$FNUMBER(x,"-")

   This uses $FNUMBER() to SET x equal to its absolute value.

2 $GET
  $GET()
   The $GET function returns the value  of  a  local  or  global  variable,
   if that variable has  a  value.  If  the  variable  has  no  value,  the
   function returns a value  specified  by  an  optional  second  argument,
   and otherwise returns a null string.

   The format for the $GET function is:

   $G[ET](glvn[,expr])

   o    The subscripted or unsubscripted  global  or  local  variable  name
        specifies the node for which $GET() returns a value

   o    If the global or local variable has a data  value,  $GET()  returns
        the value of the variable

   o    If  the  global  or  local  variable  has  no  data  value,  $GET()
        returns  the  value  of  the  optional  expression,   or   if   the
        expression is not specified, the null string

   MUMPS defines $GET(x,y) as equivalent to:

   $SELECT($DATA(x)[0:y,1:x)

   and $GET(x) as equivalent to:

   $GET(x,"")

   $GET() provides a tool to eliminate separate initialization of
   variables.  This  technique  may  provide  performance   benefits   when
   used  to  increase  the  density   of   a   sparse   global   array   by
   eliminating  nodes   that   would   otherwise   hold   absent   optional
   information. On the other hand, $GET() can mask logic problems.

   GT.M has a "NOUNDEF"  mode  of  operation,  which  treats  all  variable
   references as if they were arguments  to  a  $GET().  The  VIEW  command
   controls "NOUNDEF" mode.

3 Examples
  $GET() Examples

   Example

      I '$D(^PNT(NAME,TSTR))         S         STATUS="NEW          TEST"
      E  I ^PNT(NAME,TSTR)="" S STATUS="WAITING FOR RESULT"
      E  S STATUS=^PNT(NAME  ,TSTR)


   The above three lines of code  can  be  reduced  to  two  through  the
   use of $GET, as shown below.  However,  by  using  $GET  in  its  one-
   argument form, the  distinction  between  an  undefined  variable  and
   one with a null value is lost:

      S STATUS=$G(^PNT(NAME,TSTR))
      I STATUS="" S STATUS="WAITING FOR RESULT"

   This is solved by using the two-argument form of $GET:

      S STATUS=$G(^PNT(NAME,TSTR),"NEW TEST")
      I STATUS="" S STATUS="WAITING FOR RESULT"


2 $JUSTIFY
  $JUSTIFY()
   The $JUSTIFY function returns a formatted string.

   The format for the $JUSTIFY function is:

   $J[USTIFY](expr,intexpr1[,intexpr2])

   o    The expression specifies the string that $JUSTIFY() formats

   o    The first integer expression specifies  the  maximum  size  of  the
        resulting string

   o    If the first integer expression is larger than the  length  of  the
        expression,  $JUSTIFY()  right  justifies  the  expression   to   a
        string  of  the  specified  length  by   adding   leading   spaces,
        otherwise $JUSTIFY()  returns  the  expression  unmodified,  except
        as specified by the second integer argument

   o    The optional second integer  expression  specifies  the  number  of
        digits  after  the  decimal  point  in  the  result,   and   forces
        $JUSTIFY() to evaluate the expression as numeric;  if  the  numeric
        expression  has  more  digits  than  specified  by  this  argument,
        $JUSTIFY()  rounds  to  obtain   the   result;   if   the   numeric
        expression has  fewer  digits  than  specified  by  this  argument,
        $JUSTIFY() zero fills to obtain the result

   $JUSTIFY() provides a tool for filling expressions to create fixed
   length values. However,  if  the  length  of  the  specified  expression
   exceeds the specified field  size,  $JUSTIFY()  does  not  truncate  the
   result (although it may  still  round  based  on  the  third  (rounding)
   argument).  $EXTRACT()  provides  a  tool  for  performing   truncation,
   when required.

   $JUSTIFY() optionally rounds the portion of the result after the
   decimal  point.  In  the  absence  of  the  third  argument,  $JUSTIFY()
   does not restrict the evaluation of  the  expression.  In  the  presence
   of   the   third   (rounding)   argument,   $JUSTIFY()   evaluates   the
   expression  as  a  numeric  value.  The  rounding   algorithm   can   be
   understood as follows.  If  necessary,  it  extends  the  expression  to
   the right with zeros  (0)    to  have  at  least  one  more  digit  than
   specified by the rounding argument.  Then,  it  adds  five  (5)  to  the
   digit position after the  digit  specified  by  the  rounding  argument.
   Finally, it truncates the result to  the  specified  number  of  digits.
   In effect,  the  algorithm  rounds  up  when  excess  digits  specify  a
   half or more of the last  retained  digit  and  rounds  down  when  they
   specify  less  than  a  half.  When   the   third   argument   specifies
   rounding, $JUSTIFY() zero fills  to  provide  the  specified  number  of
   digits after the decimal.

3 Examples
  $JUSTIFY() Examples

   Example

   GTM> WRITE $JUSTIFY("HELLO",10),!,$JUSTIFY("GOODBYE",5)
        HELLO
   GOODBYE
   GTM>

   This uses $JUSTIFY() to display  "HELLO"  in  a  field  of  10  spaces
   and "GOODBYE" in a field  of  five  (5)  spaces.  Because  the  length
   of  "GOODBYE"  exceeds  five  spaces,   the   result   overflows   the
   specification.

   Example

   GTM> WRITE "1234567890",!,$JUSTIFY(10.545,10,2)
   1234567890
        10.55
   GTM>

   This uses $JUSTIFY() to WRITE  a  rounded  value  right  justified  in
   a field of ten  spaces.  Notice  that  the  result  has  been  rounded
   up.

   Example

   GTM> WRITE "1234567890",!,$JUSTIFY(10.544,10,2)
   1234567890
        10.54
   GTM>

   Again,  this  uses  $JUSTIFY()  to  WRITE  a   rounded   value   right
   justified in a field  of  ten  spaces.  Notice  that  the  result  has
   been rounded down.

   Example

   GTM> WRITE "1234567890",!,$JUSTIFY(10.5,10,2)
   1234567890
        10.50
   GTM>

   Once again, this uses  $JUSTIFY()  to  WRITE  a  rounded  value  right
   justified in a field  of  ten  spaces.  Notice  that  the  result  has
   been zero (0) filled to two places.

2 $LENGTH
  $LENGTH()
   The $LENGTH  function  returns  the  length  of  a  string  measured  in
   characters, or  in  "pieces"  separated  by  a  delimiter  specified  by
   one of its arguments.

   The format for the $LENGTH function is:

   $L[ENGTH](expr1[,expr2])

   o    The  first  expression  specifies   the   string   that   $LENGTH()
        "measures"

   o    The  optional  second  expression  specifies  the  delimiter   that
        defines  the  measure;  if  this  argument  is  missing,  $LENGTH()
        returns the number of characters in the string

   o    If the second argument is present and not a  null  string,  $LENGTH
        returns one more than the count of the  number  of  occurrences  of
        the second string in the first string; if the  second  argument  is
        a  null  string,  the  MUMPS  standard  specifies  that   $LENGTH()
        returns a zero (0)

   $LENGTH() provides a tool for determining the length of strings in
   two  ways:  characters  and  "pieces."  The   two   argument   $LENGTH()
   returns the number of existing  pieces,  while  the  one  argument  form
   returns the number of characters.

3 Examples
  $LENGTH() Examples

   Example

   GTM> WRITE $LENGTH("KINGSTON")
   8
   GTM>

   This uses $LENGTH() to WRITE  the  length  of  the  string  "KINGSTON"
   in characters.

   Example

   GTM> SET x="Smith/John/M/124 Main Street/Ourtown/KA/USA"
   GTM> WRITE $LENGTH(X,"/")
   7
   GTM>

   This uses $LENGTH() to  WRITE  the  number  of  pieces  in  a  string,
   as delimited by slash (/).

   Example

   GTM> WRITE $LENGTH("/2/3/","/")
   4
   GTM>

   This  also  uses  $LENGTH()  to  WRITE  the  number  of  pieces  in  a
   string,  as  delimited  by  slash  (/).  Notice  that  the  first  and
   last pieces count even though they are null strings.

2 $NAME
  $NAME()
   The $NAME function  returns  an  evaluated  representation  of  some  or
   all of a local or global variable name.

   The format for the $NAME function is:

   $NA[ME](glvn[,intexpr])

   o    The subscripted or unsubscripted global  or  local  variable  name,
        including naked references, specifies the name  for  which  $NAME()
        returns an evaluated representation.

   o    The optional integer expression specifies  the  maximum  number  of
        subscript  levels   in   the   representation.   If   the   integer
        expression  is  not  provided  or  exceeds  the  actual  number  of
        subscript levels, $NAME() returns a  representation  of  the  whole
        name. If the  integer  expression  is  zero  (0),  $NAME()  returns
        only the name. A negative integer expression result in an error.

3 Examples
  $NAME() Examples

   Example

   GTM> SET X="A""B",^Y(1,X,"B",4)="",WRITE $NAME(^(3),3)
   Y(1,"A""B","B")
   GTM>

   This sets up a naked  reference  and  then  uses  $NAME()  to  display
   the first three levels of that four-level reference.

2 $NEXT
  $NEXT()
   The  $NEXT  function  returns  the  next  subscripted  local  or  global
   variable  name  in   collation   sequence   within   the   array   level
   specified by its argument.

   The format for the $NEXT function is:

   $N[EXT](glvn)

   o    The subscripted global or local variable name  specifies  the  node
        following which $NEXT()  searches  for  the  next  node  with  data
        and/or descendants; the  number  of  subscripts  contained  in  the
        argument implicitly defines the array level

   o    If  $NEXT()  finds  no  node  at  the  specified  level  after  the
        specified global or local variable, it returns a minus-one (-1)

   o    If the last subscript in a subscripted  global  or  local  variable
        name is null or minus-one (-1),  $NEXT()  returns  the  first  node
        at the specified level

   $NEXT() has been replaced by $ORDER(). $NEXT has been retained in
   the current  standard  only  for  compatibility  with  earlier  versions
   of the standard.  $NEXT()  is  similar  to  $ORDER().  However,  $NEXT()
   has  the  deficiency  that  when  it  encounters  minus-one  (-1)  as  a
   subscript, it returns  the  same  result  as  when  it  finds  no  other
   data  at  the  level.  This  deficiency   is   particularly   disruptive
   because it occurs in the middle of the MUMPS collating sequence.

2 $ORDER
  $ORDER()
   The  $ORDER  function  returns  the  subscript  of  the  next  or  prior
   local  or  global  variable  name  in  collation  sequence  within   the
   array level specified by its first  argument.  In  doing  so,  it  moves
   in the direction  specified  by  the  second  argument.  In  GT.M,  when
   $ORDER() has an unsubscripted argument, it returns the next or
   previous unsubscripted  local  or  global  variable  name  in  collating
   sequence.

   The format for the $ORDER function is:

   $O[RDER](glvn[,expr])

   o    The subscripted global or local variable name  specifies  the  node
        from which $ORDER() searches for the next  or  previous  node  that
        has data and/or descendants; the  number  of  subscripts  contained
        in the argument implicitly defines the array level

   o    The  optional  expression   specifies   the   direction   for   the
        $ORDER();  a  numeric  representation  of   1   specifies   forward
        operation and a numeric  representation  of  -1  specifies  reverse
        operation; any other values for the expression cause an error

   o    GT.M extends the MUMPS standard to allow  unsubscripted  names;  in
        this case, $ORDER() returns  the  next  or  previous  unsubscripted
        name

   o    If $ORDER() finds no node (or name) at the  specified  level  after
        (or before) the specified global or local variable,  it  returns  a
        null string ("")

   o    If  the  last  subscript  in  the  subscripted  global   or   local
        variable name is null, $ORDER() returns the first  (or  last)  node
        at the specified level

   $ORDER() provides a tool for retrieving data from MUMPS sparse
   arrays in an ordered fashion, independent  of  the  order  in  which  it
   was entered. In MUMPS, routines generally  sort  by  SETting  data  into
   an  array  with  appropriate  subscripts   and   then   retrieving   the
   information with $ORDER().

   $ORDER() returns subscripts, not data values, and does not
   discriminate  between  nodes  that  have  data  values  and  nodes  that
   have descendants. Once $ORDER()  provides  the  subscript,  the  routine
   must use the  subscript  to  access  the  data  value,  if  appropriate.
   Use of  $ORDER()  maintains  the  naked  reference  indicator,  even  if
   $ORDER() returns a null.

   GT.M  permits  null  subscripts.   When   an   application   uses   null
   subscripts, they are "invisible"  in  a  $ORDER()  loop.  Therefore  the
   application must test  for  them  as  a  special  case,  e.g.,  using  a
   $DATA().

3 Examples
  $ORDER() Examples

   Example
   
   GTM> K  S (a(1),a(2000),a("CAT"),a("cat"),a("ALF"),a(12))=1
   GTM> S x="" F  S x=$O(a(x)) Q:x=""  W !,x
   1
   12
   2000
   ALF
   CAT
   cat
   GTM> KILL a("CAT") SET a(5,10)="woolworths",a("cat")="last"
   GTM> S x="" F  S x=$O(a(x),-1) Q:x=""  W !,x
   cat
   ALF
   2000
   12
   5
   1
   GTM>

   This uses a $ORDER()  loop  to  display  all  the  subscripts  at  the
   first level of local  variable  a,  makes  some  changes  in  a,  then
   displays  all  the  subscripts   in   reverse   order.   Notice   that
   $ORDER() returns only the existing subscripts in the sparse
   array  and  returns  them  in  MUMPS  collation  sequence,  regardless
   of  the  order  in  which  they  were  entered.   Also   notice   that
   $ORDER() does not differentiate between node A(5), which has
   only  descendants  (no  data  value),  and  the  other  nodes,   which
   have data values.

   Example

   GTM>k  s (%(1),tiva(2),A(3),tiv(4),Q(5),%a(6))=""
   GTM>s x="%"
   GTM>w:$d(@x) !,x f  s x=$o(@x) q:x=""  w !,x
   %
   %a
   A
   Q
   tiv
   tiva
   x
   GTM>s x="zzzzzzzz"
   GTM>w:$d(@x) !,x f  s x=$o(@x,-1) q:x=""  w !,x
   x
   tiva
   tiv
   Q
   A
   %a
   %
   GTM>

   This  loop  uses  $ORDER()  to  display  the  current  local  variable
   names in both  forward  and  reverse  order.  Notice  that  the  first
   ([^]%) and  last  ([^]zzzzzzzz)  names  require  handling  as  special
   cases.

   Example

          S acct="",cntt=""
          F  S acct=$O(^acct(acct)) Q:acct=""  D
          . F  S cntt=$O(^acct(acct,cntt)) D WORK
          Q

   This uses two  nested  $ORDER()  loops  to  cycle  through  the  ^acct
   global array and perform some action for each second level node.

2 $PIECE
  $PIECE()
   The $PIECE function  returns  a  sub-string  delimited  by  a  specified
   string delimiter made up of one or  more  characters.  In  common  MUMPS
   usage, $PIECE() returns a logical field from a logical record.

   The format for the $PIECE function is:

   $P[IECE](expr1,expr2[,intexpr1[,intexpr2]])

   o    The first expression  specifies  the  string  from  which  $PIECE()
        takes its result

   o    The  second  expression  specifies  the  delimiting   string   that
        determines the piece "boundaries";  if  this  argument  is  a  null
        string, $PIECE() returns a null string

   o    If the second expression does not  appear  anywhere  in  the  first
        expression, $PIECE() returns the entire first expression

   o    The optional  first  integer  expression  specifies  the  beginning
        piece to return; if this  argument  is  missing,  $PIECE()  returns
        the first piece

   o    The optional second integer expression  specifies  the  last  piece
        to return; if this  argument  is  missing,  $PIECE()  returns  only
        one piece, unless the first  integer  expression  is  zero  (0)  or
        negative,  in  which  case  it  returns  a  null  string;  if  this
        argument is  less  than  the  first  integer  expression,  $PIECE()
        returns a null string

   o    If the second integer  expression  exceeds  the  actual  number  of
        pieces in  the  first  expression,  $PIECE()  returns  all  of  the
        expression after the delimiter  identified  by  the  first  integer
        expression

   o    The  $PIECE()  result  never  includes  the  "outside"  delimiters;
        however,  when  the  second  integer  argument  specifies  multiple
        pieces,  the  result  contains  the  "inside"  occurrences  of  the
        delimiter

   $PIECE() provides a tool for efficiently using values that contain
   multiple  elements  or  fields,  each  of  which  may  have  a  variable
   length.

   Applications  typically  use  a  single   character   for   a   $PIECE()
   delimiter  (second  argument)  to   minimize   storage   overhead.   The
   delimiter  must  be  chosen  so  the  data  values  never  contain   the
   delimiter. Failure to enforce  this  convention  with  edit  checks  may
   result in  unanticipated  changes  in  the  position  of  pieces  within
   the data value. The circumflex (^),  back-slash  (\)  and  asterisk  (*)
   characters  are  examples  of  popular  delimiters.  Multiple  character
   delimiters  may  reduce  the   likelihood   of   conflict   with   field
   contents. However, they decrease storage efficiency.

   A SET command argument can have something  that  has  the  format  of  a
   $PIECE() on the left-hand side of its equal-sign (=). This
   construct  permits  easy  maintenance  of  individual  pieces  within  a
   string. For more information on  SET  $PIECE(),  refer  to  SET  in  the
   "Commands" chapter in the GT.M Programmer's Guide.

3 Examples
  $PIECE() Examples

   Example

   GTM> FOR i=0:1:3 WRITE !,$PIECE("1 2"," ",i),"<"
   <
   1<
   2<
   <
   GTM>

   This loop displays the result  of  $PIECE(),  specifying  a  space  as
   a  delimiter,  a  piece  position  "before"  the  string,   then   the
   first  and  second  pieces  of  the  string,  and  finally   a   piece
   position "after" the string.

   Example

   GTM> FOR i=-1:1:3 WRITE !,$PIECE("1 2"," ",i,i+1),"<"
   <
   1<
   1 2<
   2<
   <
   GTM>

   This is similar to  the  previous  example  except  that  it  displays
   two (2) pieces on each  iteration.  Notice  the  delimiter  (a  space)
   in  the  middle  of  the  output  for  the  third   iteration,   which
   successfully displays both pieces.

   Example

          F p=1:1:$L(x,"/") W ?p-1*10,$p(x,"/",p)

   This loop uses $LENGTH()  and  $PIECE()  to  display  all  the  pieces
   of x in columnar format.

2 $QUERY
  $QUERY()
   The $QUERY  function  returns  the  next  subscripted  local  or  global
   variable node  name,  independent  of  level,  which  follows  the  node
   specified by  its  argument  in  MUMPS  collating  sequence  and  has  a
   data value.

   The format for the $QUERY function is:

   $Q[UERY](glvn)

   o    The subscripted or unsubscripted  global  or  local  variable  name
        specifies the starting node from  which  $QUERY()  searches  for  a
        node with a data value

   o    If $QUERY() finds no node  after  the  specified  global  or  local
        variable, it returns a null string

   $QUERY() provides a tool for scanning an entire array for nodes
   that  have  data  values.  Because  $QUERY()   can   return   a   result
   specifying a different level than  its  argument,  the  result  provides
   a full variable name. This contrasts  with  $ORDER(),  which  returns  a
   subscript value. In order  to  access  the  data  value  at  a  node,  a
   $ORDER() return can be used as a subscript, but a $QUERY() return
   must  be  used  with  indirection.   Because   arrays   tend   to   have
   homogeneous values within a level,  but  not  between  levels,  $QUERY()
   finds more use as  a  tool  in  utility  programs  than  in  application
   programs. The $QUERY() is useful in avoiding nested $ORDER loops.

   Note  that  after  $QUERY(),  the  naked  reference  indicator  reflects
   the $QUERY() argument, NOT its result.

3 Example
  $QUERY() Example

   Example

      SET ^X(1,2,3)="123"
      SET ^X(1,2,3,7)="1237"
      SET ^X(1,2,4)="124"
      SET ^X(1,2,5,9)="1259"
      SET ^X(1,6)="16"
      SET ^X("B",1)="AB"


   This  tree  diagram  represents  the   structure   produced   by   the
   preceding routine.
   
                        ^X
                       /   \
                      /     \
                    (1)     (B)
                    / \       \
                   /   \       \
                 (2)  (6)="16" (1)="AB"
                       |
               --------+--------
              /        |        \
             /         |         \
           (3)="123"  (4)="124"  (5)
          /                         \
         /                           \
   (7)="1237"                    (9)="1259"
   

   And the following routine:

      SET y="^X"
      FOR  SET y=$QUERY(@y) QUIT:y=""  WRITE !,y,"=",@y

   produces the results:

   ^X(1,2,3)=123
   ^X(1,2,3,7)=1237
   ^X(1,2,4)=124
   ^X(1,2,5,9)=1259
   ^X(1,6)=16
   ^X("B",1)=AB


2 $RANDOM
  $Random()
   The $RANDOM function returns a  random  or  pseudo-random  integer  from
   a range specified by its argument.

   The format for the $RANDOM function is:

   $R[ANDOM](intexpr)

   o    The integer expression specifies the upper  exclusive  limit  of  a
        range  of  integers  from  which  $RANDOM()  may  pick  a   result;
        $RANDOM() never returns a number less than one (1)

   o    If $RANDOM() has an argument less than  one  (1),  it  generates  a
        run-time error

   $RANDOM() provides a tool for generating pseudo-random patterns
   useful  in  testing  or  statistical  calculations.  $RANDOM()   results
   fall between zero (0) and one less than the argument.

   Random number generators use factors  from  the  environment  to  create
   sequences  of  numbers.  True  random  number  generation   requires   a
   source of what is known as  "noise."  Pseudo-random  numbers  appear  to
   have  no  pattern,  but  are  developed   using   interactions   between
   factors that vary in ways not  guaranteed  to  be  entirely  random.  In
   accordance  with  the  MUMPS  standard,  the  GT.M   implementation   of
   $RANDOM() produces pseudo-random numbers.

3 Examples
  $RANDOM() Examples

   Example

   GTM> FOR i=1:1:10 WRITE $RANDOM(1)
   0000000000
   GTM>

   This shows that  when  $RANDOM()  has  an  argument  of  one  (1)  the
   result is too confined to be at all random.

   Example

          SET x=$RANDOM(100)+1*.01

   This $RANDOM() produces a number  between  0  and  99.    The  example
   then  shifts  with  addition  and  scales   with   multiplication   to
   create a value between .01 and 1.

2 $SELECT
  $SELECT()
   The $SELECT function returns a value  associated  with  the  first  true
   truth-valued expression in a list of paired expression arguments.

   The format for the $SELECT function is:

   $S[ELECT](tvexpr:expr[,...])

   o    If a truth-valued expression is true  (1),  $SELECT()  returns  the
        corresponding expression after the colon (:) delimiter

   o    Once $SELECT() finds a true, the  function  does  not  process  any
        remaining arguments

   o    If $SELECT() finds no true truth-value in its  list  of  arguments,
        the function generates a run-time error

   $SELECT() is one of a limited set of functions that permit an
   indefinite  number  of  arguments.  $SELECT()  provides   a   means   of
   selecting from a list of alternatives.

   Generally the last  $SELECT()  argument  has  numeric  literal  one  (1)
   for  a  truth-value  to  prevent  run-time  errors  and  to  provide   a
   "default" value.

3 Examples
  $SELECT() Examples

   Example

   GTM> F i=3:-1:0 W !,$SELECT(i=1:"hear",i=2:"come",i=3:"Watson")
   Watson
   come
   hear
   %GTM-E-SELECTFALSE,    No    argument    to    $SELECT    was     true
   GTM>

   This loop uses  $SELECT()  to  WRITE  a  series  of  strings.  Because
   there  is  no  true  argument  on  the  third  iteration,  when   i=0,
   $SELECT() produces an error.

   Example

          SET name=$E(sex="M":"Mr. ",sex="F":"Ms. ",1:"")_name

   This uses $SELECT() to prepend a  salutation  on  the  name  based  on
   a sex code held in variable  sex.  Notice  that  the  default  handles
   the case of a missing or incorrect code.

   Example

          I $S(x=+x:x,x="":0,"JANAPRJULOCT"[x:1,1:0) D THING

   This uses $SELECT() to  perform  complex  logic  as  the  truth-valued
   expression argument to an IF command.

2 $TEXT
  $TEXT()
   The $TEXT function  returns  source  text  for  the  line  specified  by
   its argument.

   The format for the $TEXT function is:

   $T[EXT](entryref)

   o    The entryref  specifies  the  label,  offset  and  routine  of  the
        source line that $TEXT() returns

   o    If the label+offset combination do not  fall  within  the  routine,
        $TEXT returns a null string

   o    If the entryref explicitly or implicitly  specifies  an  offset  of
        zero (0) from the beginning of the  routine,  $TEXT()  returns  the
        routine name

   o    If the entryref does  not  specify  a  routine,  GT.M  assumes  the
        current routine, .i.e., the routine at the top of a ZSHOW "S"

   o    A GT.M extension to  $TEXT()  permits  negative  offsets;  however,
        every  offset  must  still  be  preceded   by   a   plus-sign   (+)
        delimiter, e.g., LABEL+-3; if a negative offset points  to  a  line
        prior to the zeroth line, $TEXT() generates a runtime error

   $TEXT() provides a tool for examining routine source code and the
   name of the current routine.  $TEXT()  serves,  along  with  the  ZPRINT
   command, in  debugging  programs.  $TEXT()  also  allows  the  insertion
   of small tables of driver information  in  a  routine.  Because  $TEXT()
   is not very efficient  and  the  table-driven  technique  generally  has
   as its goal minimum  program  changes,  this  approach  is  best  suited
   to prototyping and the tables should  reside  in  global  variables  for
   production.

   In order to locate the source  code,  $TEXT()  accesses  information  in
   the routine header. If the image  does  not  currently  contain  a  copy
   of the routine, $TEXT()  initiates  an  auto-ZLINK.  If  $TEXT()  cannot
   locate the source  file  from  which  the  object  was  created  and  to
   which the  header  points,  $TEXT()  then  uses  the  $ZROUTINES  search
   matrix to  find  a  source  file  of  the  specified  name.  If  $TEXT()
   locates the source  other  than  by  use  of  the  routine  header,  the
   result  may  not  match  the  code  in  the  image  and  may   be   very
   misleading. If  $TEXT()  cannot  locate  the  source  or  cannot  access
   the  source  because  of  file  protection,  the  function  generates  a
   run-time error.

3 Examples
  $TEXT() Examples

   Example

          F i=1:1 S x=$T(+i) Q:x=""  W !,x

   This loop uses  $TEXT()  to  write  out  the  entire  source  for  the
   current routine.

   Example

   GTM> WRITE $TEXT(+0)
   GTM_DMOD
   GTM> WRITE $TEXT(+1)
   %GTM-E-FILEPARSE,    Error    parsing    file    specification:    ...
   GTM>

   This uses $TEXT() to WRITE the  name  of  the  current  routine,  then
   it  tries  to  access  the  source  and  fails.  The  failure   occurs
   because the default  Direct  Mode  image,  gtm_dmod,  is  compiled  by
   Greystone  and   delivered   without   source.   The   exact   failure
   message may vary.

2 $TRANSLATE
  $TRANSLATE()
   The  $TRANSLATE  function   returns   a   string   that   results   from
   replacing or dropping characters  in  the  first  of  its  arguments  as
   specified by the patterns of its other arguments.

   The format for the $TRANSLATE function is:

   $TR[ANSLATE](expr1[,expr2[,expr3]])

   o    The first expression specifies the  string  on  which  $TRANSLATE()
        operates

   o    The  optional  second  expression  specifies  the  characters  that
        $TRANSLATE() replaces; if this argument  is  missing,  $TRANSLATE()
        returns the first expression without modification

   o    The   optional   third   expression   specifies   the   replacement
        characters by correspondence  in  position  to  the  characters  in
        the second expression; if  this  argument  is  missing  or  shorter
        than second  expression,  $TRANSLATE()  drops  all  occurrences  of
        characters in the second expression that  have  no  replacement  in
        the corresponding position of the third expression

   o    If a character occurs more than  once  in  the  second  expression,
        the first occurrence controls  the  translation,  and  $TRANSLATE()
        ignores subsequent occurrences

   $TRANSLATE() provides a tool for tasks such as changing case and
   doing encryption.  For  examples  of  case  translation,  refer  to  the
   ^%LCASE and ^%UCASE utility routines.

3 Examples
  $TRANSLATE() Examples

   Example

   GTM> WRITE $TR("ABC","CB","1")
   A1
   GTM>

   First $TRANSLATE() tries to find  "A"  (the  first  character  in  the
   first  expression,  "ABC")  within  the  second   expression   ("CB").
   Because "A" does not  exist  in  the  second  expression,  it  appears
   unchanged  in  the  result.  Then,  $TRANSLATE()  tries  to  find  "B"
   (the second character in  the  first  expression)  within  the  second
   expression ("CB"). Because  "B"  holds  the  second  position  in  the
   second  expression  ("CB"),   $TRANSLATE()   replaces   "B"   in   the
   result with  the  character  in  the  second  position  in  the  third
   expression.  However,  as  there  is  no  second  character   in   the
   third  expression,  $TRANSLATE()  effectively  deletes  "B"  from  the
   result.    Finally,  $TRANSLATE()  tries  to  find  "C"   (the   third
   character in  the  first  expression)  within  the  second  expression
   ("CB").  Because  "C"  holds  the  first  position   in   the   second
   expression ("CB"),  $TRANSLATE()  replaces  "C"  in  the  result  with
   the  character  in  the  first  position  in  the   third   expression
   ("1"). The translated result is "A1."

   Example

   GTM> WRITE $TR("A","AA","BC")
   B
   GTM>

   This  $TRANSLATE()  finds  the  first  occurrence  of   "A"   in   the
   second expression, which  exists  in  the  first  character  position,
   and  substitutes  in  the  result   the   character   in   the   first
   position of the third expression.

   Example

   GTM> WRITE $TR("BACKUP","AEIOU")
   BCKP
   GTM>

   Because  the  $TRANSLATE()   has   only   two   parameters   in   this
   example,  it  finds  the  characters  in  the  first  expression  that
   also exist  in  the  second  expression  and  deletes  them  from  the
   result.

2 $VIEW
  $VIEW()
   The  $VIEW  function  returns   information   about   an   environmental
   factor  selected  by  the  arguments.  In  GT.M,  the   first   argument
   contains a keyword  identifying  the  environmental  factor  and,  where
   appropriate,  subsequent  arguments  select  among   multiple   possible
   occurrences of that factor.

   The format for the $VIEW() function is:

   $V[IEW](expr1[,expr2])

   o    The first expression specifies a  keyword  identifying  the  target
        factor for $VIEW() to examine

   o    The second  expression  differentiates  between  multiple  possible
        targets  for   some   keywords;   $VIEW()   requires   the   second
        expression for some keywords and does not permit it for others

   $VIEW() provides a means of accessing GT.M environmental
   information.  $VIEW()  is  similar  in  purpose  to  Intrinsic   Special
   Variables. When GT.M permits  modification  of  the  factors  accessible
   with  $VIEW(),  the  VIEW  command  generally  provides  the  tool   for
   performing the change.

3 Keywords
  $VIEW() Keywords
   These are the $VIEW() arguments and their return values:

   "BREAKMSG"                    Value of the break message mask

   "FREEBLOCKS",region                Number of free database blocks in a
                                      given  region

   "GVFILE",region               Name of database associated with the
                                 region

   "GVFIRST"                     Name of first database region in Global
                                 Directory

   "GVNEXT",region               Name of next database region after the
                                 given  one

   "GVSTAT",region               Encoded information about database
                                 behavior  since segment creation

   "ICHITS"                      Number of indirection cache hits since
                                 GT.M  image activation

   "ICMISS"                      Number of indirection cache misses since
                                 GT.M  image activation

   "JNLACTIVE",region                 Truth value showing whether
                                      journaling is  active for a region

   "JNLFILE",region              Journal file name associated with the
                                 region

   "JNLTRANSACTION"              Truth value showing how many logical
                                 transaction fences have been opened (and
                                 not  closed)
   "LABELS"                      Truth value showing whether label case
                                 sensitivity is on (1 for "LOWER") or off
                                 (0  for "UPPER")

   "REGION",gvn                  Name of region holding the given global
                                 name


   "RTNNEXT",routinename                      Name of next routine in the
                                              image after  the given one;
                                              "" for item starts with 
                                              the first routine in ASCII
                                              collating  sequence

   "SPSIZE"                      Number of bytes in the process string
                                 pool

   "STKSIZ"                      Number of bytes in the process stack

   "TOTALBLOCKS",region                       Total number of database
                                              blocks in a  given region

   "UNDEF",none                  Truth value showing whether undefined
                                 variables should be treated as having a
                                 null  value

2 $ZDATE
  $ZDATE()
   The $ZDATE function  returns  a  date  and/or  time  formatted  as  text
   based on an argument formatted in  the  manner  of  $HOROLOG.  For  more
   information  on  the  format  of  $HOROLOG,  refer  to  the   "Intrinsic
   Special Variables" chapter in the GT.M Programmer's Guide.

   The format for the $ZDATE function is:

   $ZD[ATE](expr1[,expr2[,expr3[,expr4]]]])

   o    The  first  expression  specifies  in  $HOROLOG  format  the   time
        and/or date that $ZDATE() returns in text  format;  if  the  output
        requires  only  the  date  or  the  time,  the  other   comma   (,)
        delimited piece of the argument may be null

   o    The  optional  second  expression  specifies  a  string   providing
        $ZDATE() with a "picture" of the desired  output  format;  if  this
        argument is missing or  null,  $ZDATE()  uses  the  default  format
        string "MM/DD/YY"; if the optional  second  expression  exceeds  64
        characters, $ZDATE() generates a run-time error

   o    The  optional  third  expression  specifies  a  list  of  12  month
        codes,  separated  by  commas   (,),   which   $ZDATE()   uses   in
        formatting text months called  for  by  the  "MON"  picture,  i.e.,
        $ZDATE()   outputs   $PIECE(expr3,",",month-number)   when    "MON"
        appears in the second expression; if this argument  is  missing  or
        null,  $ZDATE()  uses  three-character  English  abbreviations  for
        months

   o    The optional fourth  expression  specifies  a  list  of  seven  day
        codes,  separated  by  commas   (,),   which   $ZDATE()   uses   in
        formatting  text  days  of  the  week  called  for  by  the   "DAY"
        picture, i.e., $ZDATE() outputs
        $PIECE(expr4,",",day-of-the-week-number)  when  "DAY"  appears   in
        the second  expression;  if  this  argument  is  missing  or  null,
        $ZDATE() uses three-character English  abbreviations  for  days  of
        the week

   $ZDATE() provides an easy and flexible tool for putting MUMPS
   internal  date/time   ($HOROLOG)   formats   into   more   user-friendly
   formats.

3 Format_Elements
  $ZDATE Format Specification Elements

   YY                Outputs the rightmost two digits of the year.

   YEAR          Outputs the year as a four-digit number.

   MM            Outputs the month as a two-digit zero-filled number
                 between 01 and 12.

   MON           Outputs the month as a three-letter abbreviation.  (You
                 can modify the output further using expr3).

   DD                Outputs the day of the month as a two-digit zero-
                     filled number between 01 and 31.

   DAY           Outputs the day of the week as a three-letter
                 abbreviation. (You can modify the output further using
                 expr4).

   24                Outputs the hour of the day as a zero-filled number
                     between 00 and 23.

   12                Outputs the hour of the day as a zero-filled number
                     between 01 and 12.

   60                Outputs the minute of the hour as a zero-filled
                     number  between 00 and 59.

   SS                Outputs the second of the minute as a zero-filled
                     number between 00 and 59.

   AM            Outputs the letters AM and PM depending on the time.

   +             Inserts a plus-sign (+) in the output string

   -             Inserts a minus-sign (-) in the output string.

   .             Inserts a period (.) in the output string.

   ,             Inserts a comma (,)in the output string.

   /             Inserts a slash (/) in the output string.

   :             Inserts a colon (:) in the output string.

   ;             Inserts a semi-colon (;) in the output string.

   *             Inserts an asterisk (*) in the output string.

   Note: A blank space inserts a blank space in the output string.

3 Examples
  $ZDATE() Examples

   Example

   GTM> WRITE $H,!,$ZDATE($H)
   55243,43223
   04/01/92
   GTM>

   This displays $HOROLOG and  then  uses  $ZDATE()  to  display  today's
   date. The output shown  would  appear  if  today  were  the  first  of
   April, 1992.

   Example

   GTM> W $ZD($H,"DD-MON-YEAR")
   01-APR-1992
   GTM>

   This uses the second argument  to  specify  a  text  format  different
   from the default.

   Example

   GTM> S m="Januar,Februar,Marz,April,Mai,Juni,Juli,August,"
   GTM> S m=m_"September,October,November,Dezember"
   GTM> W $ZD($H,"DD-MON-YEAR",m)
   01-April-1992
   GTM>

   This is similar to the  prior  example,  however  it  uses  the  third
   argument to specify the months in German.

   Example

   GTM> S d="Lundi,Mardi,Mercredi,Jeudi,Vendredi,Samedi,Dimanche"
   GTM> W $ZD($H,"DAY, DD/MM/YY","",d)
   Mercredi, 01/04/92
   GTM>

   This  again  displays  the  first  of  April,  however  it  uses   the
   fourth argument to specify the days of the week in French.

2 $ZMESSAGE
  $ZMESSAGE()
   The $ZMESSAGE function  returns  a  message  string  associated  with  a
   specified status code.

   The format for the $ZMESSAGE function is:

   $ZM[ESSAGE](intexpr)

   o    The  integer  expression  specifies  the  status  code  for   which
        $ZMESSAGE() returns error message text

   $ZMESSAGE() provides a tool for examining the message associated
   with a particular message code from within GT.M.


3 Examples
  $ZMESSAGE() Examples

   Example

   GTM> write $zmessage(4)
   Interrupted system call
   GTM>

   This  uses  $zmessage()  to  display  the  message  corresponding   to
   code 4.

2 $ZPARSE
  $ZPARSE()
   The $ZPARSE function expands environment variables in file names.

   The format for the $ZPARSE function is:

   $ZPARSE(expr1[,expr2[,expr3[,expr4[,expr5]]]])

   o    The expression specifies the  file  name  to  parse;  if  the  file
        name is not valid, $ZPARSE() returns a null  string;  if  the  file
        name contains a wildcard (* and/or  ?),  the  $ZPARSE()  returns  a
        file name containing the wildcard(s)

   o    The  optional  second  expression  specifies  the  field   of   the
        file-specification that $ZPARSE()  returns;  if  this  argument  is
        missing  or  null,  $ZPARSE()  returns  a  full  file-specification
        constructed using default values in place  of  any  fields  missing
        for directory, file, and extension

   o    The optional third and fourth expressions  specify  values  to  use
        for  fields  missing  in  the  file-specifications  ahead  of   the
        process current default directory

   o    The fifth expression specifies the  mode  or  type  of  parse  that
        $ZPARSE() performs

   $ZPARSE() provides a tool for verifying that a file name is
   syntactically  correct,  for  examining  specific  fields  of   a   file
   name, and for filling in  missing  pieces  in  a  partial  specification
   based on a hierarchy of  defaults.  For  information  about  determining
   whether a file exists, refer to the section on $ZSEARCH().

   $ZPARSE() arguments, after the first, are optional. However,
   $ZPARSE() requires that missing arguments, before the last argument
   specified, be filled with null strings ("").

3 second_arg_format
  $ZPARSE 2nd Argument Format
   The field names for the second argument are:

   DIRECTORY  -  Directory name

   NAME  -  File name

   TYPE  -  File type

   The field names may be  upper-case  or  lower-case  case,  but  cannot
   be abbreviated.

   Directory specifications must end  in  a  slash;  anything  after  the
   final slash in the directory  specification  is  assumed  to  be  part
   of the name specification.

   A  file  name  with  an  extension   must   include   at   least   one
   character  to  the  left  of  the  period  (.).  Thus,  "/user/.login"
   refers  to  the  file  named  ".login,"  while  "/usr/taxes.c"  refers
   to a file named "taxes"  with  the  extension  "c."  If  a  file  name
   includes  more  than  one   period,   the   extension   includes   all
   letters to the right of the rightmost period.

3 fifth_arg_format
  $ZPARSE 5th Argument Format
   The keywords for the fifth argument $ZPARSE() are:

   NULL ("") - Returns a full file-specification.

   "SYNTAX_ONLY"  -  Disables  checking  for   the   existence   of   the
   directory or device.

   The  mode  names  may  be  upper-case  or  lower-case  but  cannot  be
   abbreviated.

3 Examples
  $ZPARSE() Examples

   Example

   GTM> WRITE $ZPARSE("TEST","","/usr/work/,""DUST.LIS")
   /usr/staff/ccc/test.lis
   GTM>

   This  uses  $ZPARSE()  to  demonstrate  defaulting  using  the   third
   argument.  The  result  gets  the  device  and  directory  field  from
   the  third  expression,  the  name  from  the  first  expression,  the
   type from the fourth extension.

2 $ZPREVIOUS
  $ZPREVIOUS()
   The $ZPREVIOUS function returns the  subscript  of  the  previous  local
   or  global  variable  name  in  collation  sequence  within  the   array
   level  specified   by   its   argument.   When   $ZPREVIOUS()   has   an
   unsubscripted argument, it  returns  the  previous  unsubscripted  local
   or global variable name in collating sequence.

   The format for the $ZPREVIOUS function is:

   $ZP[REVIOUS](glvn)

   o    The subscripted or unsubscripted  global  or  local  variable  name
        specifies  the  node   prior   to   which   $ZPREVIOUS()   searches
        backwards for a defined node  with  data  and/or  descendants;  the
        number  of  subscripts  contained  in   the   argument   implicitly
        defines the array level

   o    If $ZPREVIOUS() finds no node at the  specified  level  before  the
        specified global or local variable, it returns a null string

   o    If  the  last  subscript  in  the  subscripted  global   or   local
        variable name is null, $ZPREVIOUS() returns the last  node  at  the
        specified level

   $ZPREVIOUS() returns subscripts in the opposite order to that
   provided by $ORDER() that  has  no  second  argument  or  has  a  second
   argument of 1.

   $ZPREVIOUS() returns subscripts, not data values, and does not
   discriminate  between  nodes  that  have  data  values  and  nodes  that
   have  descendants.  Once  $ZPREVIOUS()  provides  the   subscript,   the
   routine  must  use  that  subscript  to  access  the   data   value   if
   appropriate.

   GT.M  permits  null  subscripts.   When   an   application   uses   null
   subscripts, they are  "invisible"  in  a  $ZPREVIOUS()  loop.  Therefore
   the application must test for them  as  a  special  case,  for  example,
   using a $DATA().

3 Examples
  $ZPREVIOUS() Examples

   Example

   GTM> KILL  SET X("MINE")=1,X("YOURS")=2
   GTM> W $ZPREVIOUS(X("YOURS"))
   MINE
   GTM>

   This uses $ZPREVIOUS() to  display  the  subscript  prior  to  "YOURS"
   in the local array X.

   Example

          LOCK ^PNT
          SET                        pnn=$ZPREVIOUS(^PNT("")),^(pnn+1)=%p
          LOCK

   This uses $ZPREVIOUS()  to  find  the  last  subscript  at  the  first
   level of ^PNT. Then  it  increments  the  subscript  and  uses  it  to
   store a value.

2 $ZSEARCH
  $ZSEARCH()
   The  $ZSEARCH  function  attempts  to  locate  a   file   matching   the
   specified file name. If the file  exists,  it  returns  the  file  name;
   if the file does not exist, it returns the null string.

   The format for the $ZSEARCH function is:

   $ZSEARCH(expr[,intexpr])

   o    The  expression  contains  a  file  name   for   which   $ZSEARCH()
        attempts to locate a matching file

   o    $ZSEARCH() uses the  process  current  default  directory,  if  the
        expression does not specify a directory.

   $ZSEARCH() provides a tool for verifying that a file exists. For
   information  about  determining  whether  a  file  name  is  valid,  and
   about  specifying  directories  and  file  extensions,  refer   to   the
   section on $ZPARSE().

3 Examples
  $ZSEARCH() Examples

   Example

   GTM> WRITE $ZSEARCH("data.dat")
   /usr/staff/ccc/payroll.dat
   GTM>

   This uses $ZSEARCH()  to  display  the  full  filename  of  "data.dat"
   in the process current default directory.

   Example

          S x=$ZSEARCH("*.X")
          F  S x=$ZSEARCH("*.M") Q:x=""  W !,$ZPARSE(x,"NAME")

   This  FOR  loop  uses  $ZSEARCH()  and  $ZPARSE()  to  display   MUMPS
   routines  in  the  process  current  default  directory.   To   ensure
   that the search starts  at  the  beginning,  the  example  resets  the
   context by first searching with  a  different  argument.  For  a  more
   extensive  example  of  $ZSEARCH(),  refer   to   the   ^%RD   utility
   routine.

2 $ZTRNLNM
  $ZTRNLNM()
   The $ZTRNLNM function  gives  the  value  of  an  environment  variable.
   $ZTRNLNM() optionally does iterative translation in cases where one
   environment  variable  is  set  to  the  name  of   another   environent
   variable.

   The format for the $ZTRNLNM function is:

   $ZTRNLNM(expr)

   o    The expression specifies the target environment variable

3 Examples
  $ZTRNLNM() Examples

   Example

   GTM> write $ztrnlnm("gtm_dist")
   /usr/dev/bin
   GTM>

   This  uses  $ZTRNLNM()  to   display   the   translation   value   for
   gtm_dist.



1 GOTO
  Goto Command
   The GOTO command transfers  execution  to  a  location  specified  by  its
   argument.

   The format of the GOTO command is:

   G[OTO][:tvexpr] entryref[:tvexpr][,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The  required  entryref  specifies  the  target  location   for   the
        transfer of control

   o    The  optional  truth-valued  expression  immediately  following   the
        entryref  specifies  the  argument   postconditional   and   controls
        whether GT.M performs a GOTO with that argument

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more GOTO arguments form a legal argument to a GOTO

   A GOTO command within a line  following  a  FOR  command  terminates  that
   FOR.

   For more  information  on  entryrefs,  refer  to  the  "General  Features"
   chapter in the GT.M Programmer's Guide.

2 Examples
  GOTO Examples

   Example

   GTM> GOTO TIME+4

   This GOTO transfers control from  Direct  Mode  to  the  line  four  (4)
   lines after the line labeled TIME in the currently active routine.

   Example

          GOTO A:x<0,^A:x=0,A^B

   This GOTO transfers control to label A  in  the  current  routine  if  x
   is less than zero (0), to routine ^A if x is  equal  to  zero  (0),  and
   to  label  A  in  routine  ^B  otherwise.  Once  any  of  the  transfers
   occur, the rest of the arguments have no effect.

1 HALT
  Halt Command
   The HALT  command  stops  MUMPS  program  execution  and  causes  GT.M  to
   return control to  the  operating  system  environment  that  invoked  the
   GT.M image.

   The format of the HALT command is:

   H[ALT][:tvexpr]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    Because the HALT has no  argument,  at  least  two  (2)  spaces  must
        follow the command to separate  it  from  the  next  command  on  the
        line; note that unless the HALT  has  a  postconditional,  additional
        commands serve no purpose

   A  HALT  releases  all  shared  resources  held  by  the  process,   e.g.,
   devices OPENed in MUMPS, databases, MUMPS LOCKs, etc.

   Because  HALT  and  HANG  share   the   same   abbreviation   (H),   MUMPS
   differentiates them based on whether an argument follows the command.

2 Example
  HALT Example

   Example

   $ GTM

   %GTM-I-BREAK, Break instruction encountered
                   At MUMPS source location +1^GTM$DMOD
   GTM> HALT

   $

   Because we invoke this GT.M image  interactively,  the  HALT  in  Direct
   Mode leaves the process at the shell prompt.

1 HANG
  Hang Command
   The HANG command suspends MUMPS program execution for  a  period  of  time
   specified by the command argument.

   The format of the HANG command is:

   H[ANG][:tvexpr] numexpr[,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The numeric expression  specifies  the  time  in  seconds  to  elapse
        before resuming execution; actual  elapsed  time  may  vary  slightly
        from the specified time; HANG only uses the integer  portion  of  the
        numeric expression

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more HANG arguments form a legal argument to a HANG

   A process  that  repeatedly  tests  for  some  event,  such  as  a  device
   becoming available or another process modifying  a  global  variable,  may
   use a HANG to limit its consumption of computing resources.

   Because  HALT  and  HANG  share   the   same   abbreviation   (H),   MUMPS
   differentiates them based on whether an argument follows the command.

2 Examples
  HANG Examples

   Example

          FOR  QUIT:$D(^CTRL(1))  HANG 30

   This FOR loop repeatedly  tests  for  the  existence  of  ^CTRL(1),  and
   terminates when that  global  variable  exists.  Otherwise  the  routine
   HANGs for 30 seconds and tests again.

   Example

          S t=1 F  Q:$D(^CTRL(1))  H t I t<30 S t=t+1

   This is similar  to  the  previous  example,  except  that  it  uses  an
   adaptive  time  which  lengthens  from  1  second  to  a  limit  of   30
   seconds if the routine stays in the loop.

1 IF
  If Command
   The  IF  command  provides  conditional   execution   of   the   remaining
   commands on the line. When IF has an argument,  it  maintains  $TEST  with
   the  truth  value  of  its  evaluated   argument.   MUMPS   executes   the
   remainder of a line after an IF statement when $TEST  is  1  (true).  When
   $TEST is 0 (false), MUMPS does not execute the rest of the line.

   The format of the IF command is:

   I[F] [tvexpr[,...]]

   o    Because IF is a conditional command, it does not  support  a  command
        postconditional

   o    The scope of the IF is the remainder of the line

   o    IF assigns the evaluation  of  optional  truth-valued  expression  to
        $TEST

   o    $TEST controls the action of the IF

   o    The IF command with no  argument  relies  on  the  current  value  of
        $TEST (which it does not change); in this  case,  at  least  two  (2)
        spaces must follow the IF to separate it from  the  next  command  on
        the line

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more IF arguments form a legal argument to an IF

   Note that commands with timeouts  also  maintain  $TEST.  For  information
   about $TEST, refer to the "Intrinsic Special  Variables"  chapter  in  the
   GT.M  Programmer's  Guide.  Because  MUMPS  stacks  $TEST  only   at   the
   execution of an extrinsic or an argumentless DO  command,  any  XECUTE  or
   DO with an argument has the  potential  side  effect  of  altering  $TEST.
   Therefore, use the argumentless IF with caution.

   Because

          IF A,B ...

   is equivalent to

          IF A IF B

   an IF with more  than  one  argument  acts  as  if  those  arguments  were
   logically  "ANDed."  However,  execution  of  the  line  ceases  with  the
   evaluation of the  first  false  argument.  For  IF  argument  expressions
   containing  the  "AND"  operator  (&)  execution  still  ceases  with  the
   evaluation  of  the  first  false  argument,  but  any  global  references
   within the expression act in sequence to maintain the naked reference.

   Postconditionals  perform  a  similar  function  to  IF,  however,   their
   scope is limited to a single command  and  they  do  not  maintain  $TEST.
   For  more  information  on  postconditionals,  refer   to   the   "General
   Features" chapter in the GT.M Programmer's Guide.

2 Examples
  IF Examples

   Example

          IF x=+x!(x="") DO BAL

   If x contains a number or a null string, the DO executes.

   Example

          WRITE !,?50,bal IF 'bal WRITE "****"
          IF  S EMPTY(acct)=""

   The IF in the  first  line  changes  the  value  of  $TEST,  determining
   the  execution  of  the  code  following  the  argumentless  IF  in  the
   second line.  Such  argumentless  IFs  may  serve  as  a  form  of  line
   continuation.

   Example

   GTM> SET X=1,Y=1,Z=2 KILL UNDEF
   GTM> IF X=1,Y=1,Z=3,UNDEF=0 W "HI"
   GTM>

   The IF command causes  MUMPS  to  cease  executing  the  line  after  it
   determines  Z  is  not  equal  to  three  (3).  Therefore,  MUMPS  never
   evaluates the reference  to  the  undefined  variable  and  consequently
   never generates an error.

   Example

   GTM> SET X=1 KILL UNDEF
   GTM> IF X=1!(UNDEF=3) W "HI"
   HI
   GTM>

   Because  GT.M  recognizes  that  the  X=1  fulfills  the  IF,  it  skips
   evaluation  of  the  UNDEF  variable  and  executes  this   IF   command
   without generating  an  error.  Because  MUMPS  does  not  require  such
   optimizations and  in  fact  discourages  them  by  requiring  that  all
   global    references    maintain    the    naked    indicator,     other
   implementations may generate an error.

1 JOB
  Job Command
   The JOB command  forks  another  GT.M  process  that  executes  the  named
   routine.

   The format of the JOB command is:

   J[OB][:tvexpr]           entryref[(expr[,...])][:[(keyword[=value][:...])]
   [:numexpr]][,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The required entryref specifies a location at which the  new  process
        starts

   o    The optional parameter  list  enclosed  in  parentheses  ()  contains
        parameters to pass to the routine entry point

   o    If the JOB specifies a parameter list,  the  entryref  location  must
        start with a label and  an  argument  list.  In  other  words,  MUMPS
        prohibits entryrefs with offsets during parameter passing

   o    The optional elements  in  the  parameter  list  specify  expressions
        that the JOB evaluates and passes as a value

   o    The keywords specify optional jobparameters that control  aspects  of
        the environment for the new process

   o    If the  JOB  command  has  only  one  jobparameter,  the  surrounding
        parentheses are optional

   o    Some keywords take numeric or string literals as  arguments;  because
        the values are constants, strings must  be  enclosed  in  quotes  (")
        and variable arguments require indirection

   o    The optional numeric expression specifies a  time  in  seconds  after
        which the command  should  timeout  if  unsuccessful;  0  provides  a
        single attempt

   o    When a JOB command contains  no  jobparameters,  double  colons  (::)
        separate the timeout numeric expression from the entryref

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more  JOB  arguments  form  a  legal  argument  for  a  JOB
        command

   The operating system deletes the forked  process  when  execution  of  the
   GT.M process is complete. Upon termination  of  the  parent  process,  the
   forked process is reassinged to init.

   If a JOB command specifies a  timeout,  and  GT.M  creates  the  resultant
   process before the timeout  elapses,  JOB  sets  $TEST  to  true  (1).  If
   GT.M cannot create the process within  the  specified  timeout,  JOB  sets
   $TEST to false (0). If a JOB command does not specify a timeout, the
   execution of the command does not affect $TEST.

2 DEFAULT
  DEF[AULT]=strlit
   The string literal specifies the default directory.

   The maximum directory length is 255 characters.

   If the JOB command does not  specify  a  DEFAULT  directory,  GT.M  uses
   the current default directory of the parent process.

2 ERROR
  ERR[OR]=strlit
   The string literal specifies a value for stderr.

   The maximum string length is 255 characters.

   By  default,  JOB  constructs  the  error  file-specification  from  the
   routinename using a file extension  of  .mje  and  the  current  default
   directory of the process created by the JOB command.

2 GBLDIR
  GBL[DIR]=strlit
   The string literal  specifies  a  value  for  the  environment  variable
   gtmgbldir.

   The maximum length of the translated name is 255 characters.

2 INPUT
  IN[PUT]=strlit
   The string literal specifies a value for stdin.

   The maximum string length is 255 characters.

   By default, the job takes its input from the null device.

2 OUTPUT
  OUT[PUT]=strlit
   The string literal specifies a value for stdout.

   GT.M does not supply a default file extension.

   The maximum string length is 255 characters.

   By default,  JOB  constructs  the  output  file-specification  from  the
   routinename using a file extension  of  .mjo  and  the  current  default
   directory of the process created by the JOB command.

2 STARTUP
  STA[RTUP]=strlit
   The string literal specifies a command  line  that  the  shell  executes
   before executing the MUMPS routine.

2 Example
  JOB Example

   Example

   GTM> JOB ^TEST

   This creates a detached job that  starts  doing  the  routine  ^TEST  in
   the current default directory.

1 KILL
  Kill Command
   The  KILL  command  deletes  local   or   global   variables   and   their
   descendant nodes.

   The format of the KILL command is:

   K[ILL][:tvexpr] [glvn|(lvn[,...])[,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional global or local variable  name  specifies  the  variable
        to delete; KILL deletes  not  only  the  variable  specified  in  the
        argument, but also all variables descended from that  variable  i.e.,
        which start with the identical key-prefix

   o    KILLing a variable that does not currently exist has no effect

   o    The KILL command without an argument deletes all  currently  existing
        local variables; in this case, at least two (2)  spaces  must  follow
        the KILL to separate it from the next command on the line

   o    When a KILL argument is enclosed  in  parentheses,  that  "exclusive"
        KILL  deletes  all  local  variables  except  those  listed  in   the
        argument

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more KILL arguments form a legal argument for a KILL

   KILL  does  not  affect  copies  of  local  variables   that   have   been
   "stacked" by NEW or parameter passing.

   Because a KILL can have a large impact, use KILL with caution.

2 Examples
  KILL Examples

   Example

   GTM> KILL  SET a=0,a(1)=1,a(1,1)="under" KILL a(1) ZWR
   a=0
   GTM>

   This uses an argumentless KILL  to  get  a  "fresh  start"  by  deleting
   all existing  local  variables.  After  SETting  a,  a(1),  and  a(1,1),
   the KILL deletes a(1) and its  descendants.  The  ZWRITE  shows  only  a
   remaining.

   Example

   GTM> KILL (a,b),^AB(a,b)

   The first argument (an exclusive  KILL)  specifies  to  KILL  all  local
   variables except a and b.  The  second  argument  deletes  ^AB(a,b)  and
   any descendants that global variable node might have.

1 LOCK
  Lock Command
   The  LOCK  command  provides  a  mutual  exclusion  capability  for  MUMPS
   processes by reserving and releasing resource  names.  The  LOCKs  can  be
   used  for  interprocess  synchronization  and  signaling.  Note  that  the
   LOCK does NOT have anything explicitly  to  do  with  variables  and  does
   NOT directly affect either read or  write  access  to  global  (or  local)
   data. However, an application  that  adheres  to  conventions  of  LOCKing
   before access can indirectly achieve such an effect.

   The format of the LOCK command is:

   L[OCK][:tvexpr] [[-|+]nref|(nref[,...])[:numexpr][,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The nref argument specifies a name in the format  of  a  MUMPS  local
        or global variable name, with or without subscripts

   o    Only one process in an environment can own a particular LOCK  at  any
        given time

   o    Because the data storage in MUMPS uses  hierarchical  sparse  arrays,
        and LOCK frequently serves to protect that  data  from  inappropriate
        "simultaneous" access by multiple  processes,  LOCK  treats  resource
        names in a hierarchical fashion; a LOCK protects not only  the  named
        resource, but also its ancestors and descendants

   o    When  one  or  more  nrefs  are  enclosed  in  parentheses  (),  LOCK
        reserves all the enclosed names "simultaneously," i.e.,  it  reserves
        none of them until all become available

   o    A LOCK  with  no  argument  or  an  argument  with  no  leading  sign
        releases all names currently reserved  with  previous  LOCK  commands
        by the process; in this case, at least two  (2)  spaces  must  follow
        the LOCK to separate it from the next command on the line

   o    A LOCK argument with a  leading  plus-sign  (+)  acquires  the  named
        resources without releasing currently held resources;  if  the  named
        resource is already LOCKed, such  a  LOCK  "counts  up"  the  process
        interest in the resource

   o    A LOCK argument with a  leading  minus-sign  (-)  "counts  down"  the
        process interest in a named resource;  if the count on  a  particular
        lock reaches zero (0), MUMPS  releases  the  lock  without  releasing
        any other currently held  locks;    a  LOCK  that  releases  a  named
        resource not currently owned by the process has no effect

   o    The optional numeric expression specifies a  time  in  seconds  after
        which the command  should  timeout  if  unsuccessful;  0  provides  a
        single attempt

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more LOCK arguments form a legal argument for a LOCK

   GT.M records LOCK  and  ZALLOCATE  information  in  the  "lock  database."
   GT.M  distributes  the  lock  database  in  space  associated   with   the
   database files  identified  by  the  current  Global  Directory.  However,
   the lock database does not overlap  or  coincide  with  the  body  of  the
   database files holding the global  data.  Only  the  LOCK,  ZALLOCATE  and
   ZDEALLOCATE  commands,  and  the  LKE  utility  program  access  the  lock
   database.

   GT.M  maps  reservations  of  global  names  (starting  with  ^)  to   the
   database file used to map variables of the  same  name.  If  the  GD  maps
   the name A to file A.DAT,  GT.M  maps  all  reservations  on  ^A  to  file
   A.DAT.

   GT.M maps reservations on  local  names  (not  starting  with  ^)  to  the
   region of the database specified  with  the  GDE  command  LOCK  /REGION=.
   By default GDE creates GDs mapping reservations  of  local  names  to  the
   region, DEFAULT.

   These 2 factors result in the following:

   o    ^ reservations automatically intersect for  all  users  of  the  same
        data in any database file independent of the GD mapping that file

   o    "local" reservations intersect in an arbitrary pattern  dependent  on
        the  GD  and  therefore  controlled  by  a   design   decision   made
        independently of application code design

   Because MUMPS uses  resource  names  as  semaphores  for  signaling  among
   multiple processes in a database environment, they  interlock  in  a  tree
   structured  fashion.  When  LOCK  or  ZALLOCATE  reserves  a   subscripted
   resource name such as ^D(1), other  users  of  the  lock  database  mapped
   by the LOCKing (or  ZALLOCATEing)  process  cannot  reserve  ancestors  of
   that name such as ^D  or  descendants  such  as  ^D(1,2),  until  LOCK  or
   ZDEALLOCATE releases that name.

   The LOCK command locks a specified resource  name  that  controls  a  tree
   structured name space. Once one  process  in  an  environment  acquires  a
   LOCK or a ZALLOCATE on  a  named  resource,  no  other  MUMPS  process  in
   that environment can LOCK a resource  with  an  "overlapping"  name  until
   the first process releases the LOCK that it holds.

   Execution of the LOCK command does not  affect  the  value  or  the  state
   of a variable. LOCK tests each lockargument to  see  if  the  process  can
   claim the name space. If another MUMPS process has a  LOCK  on  that  name
   space,  GT.M  suspends  the  current  process  until  the  other   process
   releases  the  name   space.   To   prevent   the   potential   "infinite"
   suspension of  a  routine  execution,  specify  a  timeout  for  the  LOCK
   command.

   LOCK with  a  leading  +  or  -  sign  (incremental  LOCKing)  allows  the
   acquisition of locks without releasing  currently  held  locks.  This  can
   lead to deadlocks. For example,  a  deadlock  occurs  if  two  users  LOCK
   resources named A and B in the following sequence.

   To  avoid  deadlocks,  use  a  timeout  with  the  LOCK  command.    LOCKs
   without a leading +  or  -  sign  on  their  arguments  prevent  deadlocks
   because the command releases all previously LOCKed resources.

   If  a  process  issues  a  LOCK  command  for  a  named  resource  already
   ZALLOCATEd  by  that  process,  the  resource  is  both   ZALLOCATEd   and
   LOCKed. LOCK does not release ZALLOCATEd  resources.  To  release  such  a
   named  resource,  the  process  must  both  ZDEALLOCATE  and  unLOCK   the
   resource. For more  information  on  the  interaction  between  LOCKS  and
   ZALLOCATE, refer to the "ZALLOCATE" section of this chapter.

   For  more  information  on  troubleshooting  locks  with  the  MUMPS  Lock
   Utility  (LKE),  refer  to  the  chapter  on  that  utility  in  the  GT.M
   Administration and Operations Guide.

   For information on the use of LOCKs  within  TRANSACTIONs,  refer  to  the
   chapter on "General Features" in the GT.M Programmer's Guide.


2 Examples
  LOCK Examples

   Example

          L A,^B,@C
          L (A,B,@C)

   The first LOCK  command  LOCKs  A  and  unlocks  A  before  LOCKing  ^B,
   then unlocks ^B before  locking  the  name  specified  by  the  variable
   C. The second  LOCK  command  acquires  all  three  resources  at  once.
   MUMPS waits  until  all  the  variables  in  the  argument  list  become
   available  before  locking  all  the  resources.  For  example,  if  the
   resource specified by the variable  C  is  not  available  for  LOCKing,
   MUMPS waits until that  resource  becomes  available  before  locking  A
   and B.

   Example

          L (A,B)
          L +C
          L -B

   This LOCKs A and B, then incrementally  LOCKs  C.  Finally  it  releases
   the LOCK on B, while retaining the LOCKs on A and C.

   Example

          L (A,B,C)
          L +(B,C)
          L -(B)

   This LOCKs A,B and C together. It  then  increments  the  lock  "counts"
   of B and C. The last LOCK command removes  one  "count"  of  B,  leaving
   one count of A and B and two counts of C.

   Example

          L ^D:5

   This command attempts to LOCK ^D with a  timeout  of  five  seconds.  If
   LOCK acquires the named  resource  before  the  timeout  elapses,  MUMPS
   sets $TEST to 1 (true). If LOCK fails  to  acquire  the  named  resource
   before the timeout elapses, MUMPS sets $TEST to 0 (false).

1 MUMPS
  MUMPS command
   The mumps command  invokes  the  compiler  to  translate  a  MUMPS  source
   file into object code.

   The format for the MUMPS command is:

   MUMPS[-qualifier[...]] file_spec

   o   Qualifiers determine characteristics of the compiler output

   o   Qualifiers are applied globally no matter where  they  appear  in  the
       command

   o   Each  file-specification  identifies  a  MUMPS   source   program   to
       compile

   o   Source programs must have an extension of .m (lowercase)

   o   GT.M allows the * and ? wildcards in a file-specification

   o   The  *  wildcard  accepts  any  legal  number   and   combination   of
       characters including a null, in the position the wildcard holds

   o   The ? wildcard accepts exactly one legal character in its position

2 Qualifiers
-DIRECT_MODE
  -DI[RECT_MODE]
   Invokes  a  small  GT.M  image  that  immediately   initiates   Direct
   Mode.

   -DIRECT_MODE does not invoke the MUMPS compiler.

   The   -DIRECT_MODE   qualifier   is   incompatible   with    a    file
   specification.

-RUN
  -R[UN]
   Invokes GT.M in Autostart Mode. The  next  argument  is  taken  to  be
   a  MUMPS  entryref,  and  that  routine   is   immediately   executed,
   bypassing direct mode.  Depending  on  the  shell,  you  may  need  to
   put the entryref in quotes.

1 NEW
  New Command
   The NEW command "stacks"  copies  of  local  variables  and  reinitializes
   the variables.  An  explicit  or  implicit  QUIT  from  a  DO,  XECUTE  or
   extrinsic function "unstacks"  the  NEWed  variables,  that  is,  restores
   the variable to the stacked value.  A  NEW  lasts  only  for  the  current
   scope of execution and  is  analogous  to  a  KILL  which  MUMPS  reverses
   when leaving the current scope.

   The format of the NEW command is:

   N[EW][:tvexpr] [[(]lname[,...][)][,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    NEW arguments are unsubscripted local variable names

   o    NEW affects not only the variable  specified  in  the  argument,  but
        also all variables descended from that variable, that  is,  variables
        starting with the identical key-prefix

   o    When a variable that is undefined is  NEWed,  the  fact  that  it  is
        undefined is "stacked",  and  when  leaving  the  current  scope,  it
        returns to being undefined, i.e., the variable is KILLed

   o    The NEW command without  an  argument  NEWs  all  currently  existing
        local variables; in this case, at least two (2)  spaces  must  follow
        the NEW to separate it from the next command on the line

   o    When a NEW argument is  enclosed  in  parentheses,  that  "exclusive"
        NEW affects all local variables except those listed in  the  argument
   

   o    When the flow of execution leaves the scope of  an  argumentless  NEW
        or exclusive NEW, MUMPS  restores  all  stacked  variables  to  their
        previous values, and deletes all other local variables

   o    The intrinsic  special  variable  $ZTRAP  can  also  be  an  explicit
        argument of a NEW; this  stacks  the  current  value  of  $ZTRAP  and
        assigns $ZTRAP a null value ($ZTRAP="")

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more NEW arguments form a legal argument for a NEW

   An explicit or implicit  QUIT  from  the  MUMPS  virtual  stack  level  at
   which a NEW occurred restores the saved  values  and  deletes  any  values
   assigned after the NEW.

   The NEW  command  provides  a  means  of  confining  the  scope  of  local
   variables. NEW operates only on unsubscripted  local  names  and  acts  on
   the entire named array.

2 Examples
  NEW Examples

   Example

          SET A(1)=1,B=4,C=5
          WRITE !,"VARIABLES BEFORE NEW:",!
          ZWRITE
          DO LABEL
          WRITE !,"VARIABLES AFTER RETURN:",!
          ZWRITE
          QUIT
   LABEL  NEW A SET C=7
          WRITE !,"VARIABLES AFTER NEW:",!
          ZWRITE
          QUIT

   Produces the results:

   VARIABLES BEFORE NEW:
   A(1)=1
   B=4
   C=5

   VARIABLES AFTER NEW:
   B=4
   C=7

   VARIABLES AFTER RETURN:
   A(1)=1
   B=4
   C=7


   Example

          SET (A,B,C,D)="TEST"
          DO LABEL
          WRITE !,"VARIABLES AFTER RETURN:",!
          ZWRITE
          QUIT
   LABEL  NEW (B,C) SET (A,Z)="NEW"
          WRITE      !,"VARIABLES       AFTER       EXCLUSIVE       NEW:",!
          ZWRITE
          QUIT

   Produces the results:

   VARIABLES AFTER EXCLUSIVE NEW:
   A="NEW"
   B="TEST"
   C="TEST"
   Z="NEW"

   VARIABLES AFTER RETURN:
   A="TEST"
   B="TEST"
   C="TEST"
   D="TEST"

1 OPEN
  O[PEN]
   The OPEN command establishes a  connection  from  a  MUMPS  process  to  a
   device.

   The format of the OPEN command is:

   O[PEN][:tvexpr] expr[:[(keyword[=expr][:...])][:numexpr]][,...]

   o   The  optional  truth-valued  expression  immediately   following   the
       command is a  command  postconditional  which  controls  whether  GT.M
       executes the command or not

   o   The required expression specifies the device to OPEN

   o   The optional keywords specify deviceparameters  which  control  device
       behavior

   o   If the argument only contains  one  deviceparameter,  the  surrounding
       parentheses are optional

   o   The optional numeric expression specifies  a  time  in  seconds  after
       which the  command  should  timeout  if  unsuccessful;  0  provides  a
       single attempt to open the device

   o   When   an   OPEN   command   specifying   a   timeout   contains    no
       deviceparameters, double colons  (::)  separate  the  timeout  numeric
       expression from the device expression

   o   An indirection operator and an expression atom evaluating  to  a  list
       of one or more OPEN arguments form a legal argument for an OPEN

   By  default,  when  a  device  is  unavailable,  GT.M  retries  the   OPEN
   indefinitely  at  approximately  one  second  intervals.   A   device   is
   unavailable when the OPENing process does  not  have  the  resources  left
   to open the device. All other errors on  OPEN  raise  an  error  condition
   and interrupt program flow. A  timeout  provides  a  tool  for  the  MUMPS
   routine to regain program  control  when  a  device  remains  unavailable.
   When the OPEN specifies  a  timeout,  GT.M  keeps  retrying  until  either
   the OPEN succeeds at which time  GT.M  sets  $TEST  to  true  (1)  or  the
   timeout expires at which time GT.M and  sets  $TEST  false  (0).  An  OPEN
   with  a  timeout  and  no  deviceparameters  must  have  two  colons  (::)
   between the argument expression and the timeout.

   If a process has not previously OPENed a  device  within  the  context  of
   an image, any  deviceparameters  not  supplied  on  the  OPEN  take  their
   default values. When reOPENing a  device  that  it  previously  closed,  a
   MUMPS process restores all  characteristics  not  specified  on  the  OPEN
   to the values the  device  had  when  it  was  last  CLOSEd.  GT.M  treats
   sequential disk  files  differently  and  uses  defaults  for  unspecified
   sequential disk file characteristics on every OPEN.  That  is,  GT.M  does
   not retain sequential  disk  file  characteristics  on  a  CLOSE.  If  you
   have a menu-driven application that OPENs  and  CLOSEs  devices  based  on
   user selections,  take  care  that  every  OPEN  explicitly  includes  all
   deviceparameters  that  matter  to  the  application.  GT.M  always   sets
   sequential    disk    file    characteristics    not    specified     with
   deviceparameters on OPEN to their default values.

   If  a  process  OPENs  an  already  OPEN   device,   GT.M   modifies   any
   characteristics  that  can  be  changed  while  the  device  is  OPEN   to
   reflect any new deviceparameters.

2 Examples
  OPEN Examples

   Example

   S sd="report.dat" OPEN sd:NEWVERSION

   This OPENs a NEWVERSION of a  seqential  disk  file  named  "report.dat"
   for both read and write access.

2 APPEND
  APPEND
   Positions the file pointer  at  the  end-of-file.  This  deviceparameter
   only affects the  device  on  the  first  OPEN  command.  Re-OPENing  an
   already OPEN device with this deviceparameter has no effect.

   By default, OPEN sets the file pointer to the beginning-of-file.

2 BLOCKSIZE
  BLOCKSIZE=intexpr
   Specifies the size in bytes of the maximum  single  read  or  write  for
   the specified device.


2 CONTIGUOUS
  CONTIGUOUS
   Specifies  that  the   operating   system   must   allocate   physically
   contiguous (adjacent)  disk  space  for  a  new  file.  If  disk  cannot
   supply the required amount of contiguous space, the OPEN fails.

   By  default,   the   operating   system   uses   a   contiguous-best-try
   algorithm.  The  algorithm   uses   contiguous   space   if   available;
   otherwise, it pieces the file together  out  of  the  largest  available
   extents.

2 EXCEPTION
  EXCEPTION=expr
   Defines an  error  handler  for  an  I/O  device.  The  expression  must
   contain a  fragment  of  MUMPS  code  (e.g.,  GOTO  ERRTAPE)  that  GT.M
   XECUTEs when the driver for the device detects an error.

   For more  information  on  error  handling,  refer  to  the  "Processing
   Errors" chapter in the GT.M Programmer's Guide.

2 GROUP
  GROUP
   Specifies  permission  on  UNIX  files.  The  expression   is   a   mask
   evaluating  to  null  or  to  any  combination  of  the   letters   RWX,
   indicating respectively  Read,  Write,  and  eXecute  access.  When  any
   one of these deviceparameters appears on an OPEN  of  a  new  file,  any
   user category that is not explicitly  specified  is  given  the  default
   mask. When any one of these  deviceparameters  appears  on  an  OPEN  of
   an  existing  file,  any  user   category   that   is   not   explicitly
   specified is unchanged.

   In order to modify file security, the user  who  issues  the  OPEN  must
   have ownership.

   By default,  OPEN  does  not  modify  the  permissions  on  an  existing
   file. Unless otherwise specified, when  OPEN  creates  a  new  file,  it
   establishes security using standard defaulting rules.

2 NEWVERSION
  NEWVERSION
   The NEWVERSION deviceparameter creates a new version of the file.

2 OWNER
  OWNER
   Specifies  User  access  on  UNIX  files.  The  expression  is  a   mask
   evaluating  to  null  or  to  any  combination  of  the   letters   RWX,
   indicating respectively  Read,  Write,  and  eXecute  access.  When  any
   one of these deviceparameters appears on an OPEN  of  a  new  file,  any
   user category that is not explicitly  specified  is  given  the  default
   mask. When any one of these  deviceparameters  appears  on  an  OPEN  of
   an  existing  file,  any  user   category   that   is   not   explicitly
   specified is unchanged.

   In order to modify file security, the user  who  issues  the  OPEN  must
   have ownership.

   By default,  OPEN  does  not  modify  the  permissions  on  an  existing
   file. Unless otherwise specified, when  OPEN  creates  a  new  file,  it
   establishes security using standard defaulting rules.

2 READONLY
  [NO]READONLY
   OPENs a device for  reading  only  (READONLY)  or  reading  and  writing
   (NOREADONLY).

   To open a  sequential  file  using  the  READONLY  parameter,  the  file
   must exist  on  the  disk  or  magnetic  tape.  If  it  does  not,  GT.M
   issues a run-time error.

   When  GT.M  encounters  a  WRITE  directed  to  a  fileor  tape   OPENed
   READONLY, GT.M issues a run-time error.

   By   default,   OPEN   accesses   the   device   or   file    NOREADONLY
   (read-write).

2 REWIND
  REWIND
   REWIND positions the file pointer of  a  sequential  disk  file  to  the
   first record.

   REWIND positions foreign tapes at the BOT marker.

   By default, OPEN does not REWIND.

2 SYSTEM
  SYSTEM
   Specifies  permission  on  UNIX  files.  The  expression   is   a   mask
   evaluating  to  null  or  to  any  combination  of  the   letters   RWX,
   indicating respectively  Read,  Write,  and  eXecute  access.  When  any
   one of these deviceparameters appears on an OPEN  of  a  new  file,  any
   user category that is not explicitly  specified  is  given  the  default
   mask. When any one of these  deviceparameters  appears  on  an  OPEN  of
   an  existing  file,  any  user   category   that   is   not   explicitly
   specified is unchanged.

   In order to modify file security,  the  user  who  issues  the  OPEN  or
   CLOSE must have ownership.

   By default,  OPEN  does  not  modify  the  permissions  on  an  existing
   file. Unless otherwise specified, when  OPEN  creates  a  new  file,  it
   establishes security using standard defaulting rules.

2 UIC
  UIC=expr
   Establishes the  file's  group  name,  which  specifies  the  the  group
   that has access to the file.

2 VARIABLE
  VARIABLE
   Specifies the VARIABLE record length  format  for  sequential  disk  and
   magnetic tape files.

   VARIABLE length records  on  disk  start  with  two  bytes  of  overhead
   for  the   device   driver   which   hold   the   actual   record-length
   represented  as  a  two's  complement  binary  number.  VARIABLE  length
   tape records start with  four  bytes  of  overhead,  and  represent  the
   length  as  ASCII  digits.  A  BLOCKSIZE  for  VARIABLE  length  records
   must  specify  at  least  four  bytes  more  than  the  maximum   record
   length.

   By default, records have VARIABLE length.

2 WORLD
  WORLD
   Specifies  Other  access  on  UNIX  files.  The  expression  is  a  mask
   evaluating  to  null  or  to  any  combination  of  the   letters   RWX,
   indicating respectively  Read,  Write,  and  eXecute  access.  When  any
   one of these deviceparameters appears on an OPEN  of  a  new  file,  any
   user category that is not explicitly  specified  is  given  the  default
   mask. When any one of these  deviceparameters  appears  on  an  OPEN  of
   an  existing  file,  any  user   category   that   is   not   explicitly
   specified is unchanged.

   In order to modify file security, the user  who  issues  the  OPEN  must
   have ownership.

   By default,  OPEN  and  CLOSE  do  not  modify  the  permissions  on  an
   existing file. Unless otherwise  specified,  when  OPEN  creates  a  new
   file, it establishes security using standard defaulting rules.

2 WRAP
  [NO]WRAP
   Enables or disables  automatic  record  termination.  When  the  current
   record size ($X) reaches the maximum  WIDTH  and  the  device  has  WRAP
   enabled, GT.M starts a new record,  as  if  the  routine  had  issued  a
   WRITE ! command.

   NOWRAP causes GT.M to  require  a  WRITE  !  to  terminate  the  record.
   NOWRAP  allows  $X  to  become  greater  than  the  device   WIDTH   for
   terminals and null devices.

   By default, records WRAP.

1 QUIT
  Quit Command
   Except when a QUIT appears on  a  line  after  a  FOR,  the  QUIT  command
   terminates execution of the current  MUMPS  virtual  stack  level  created
   by a DO, XECUTE or extrinsic function  or  special  variable,  and  causes
   resumption of the next "lower" level. In  this  case,  QUIT  restores  any
   values stacked at the current level by an extrinsic or  by  NEWs.  When  a
   QUIT appears on the line following a  FOR,  the  QUIT  command  terminates
   execution of the FOR.

   The format of the QUIT command is:

   Q[UIT][:tvexpr] [expr]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    When a QUIT  terminates  an  extrinsic  function,  it  must  have  an
        argument that supplies the value returned by  the  function;  in  all
        other cases, QUIT must not have an argument  and  at  least  two  (2)
        spaces must follow the command to separate it from the  next  command
        on the line

   o    An indirection operator and an expression atom evaluating to  a  QUIT
        argument form a legal argument for a QUIT

   QUIT performs two similar, but  in  fact  different,  functions  depending
   on its context. Because FORs do  not  add  levels  to  the  MUMPS  virtual
   stack, QUITs inside FOR  loops  simply  terminate  the  loop.  QUITs  that
   terminate DOs,  XECUTEs  and  extrinsics  remove  a  MUMPS  virtual  stack
   level and therefore may adjust  the  local  variable  environment  due  to
   previous NEWs or parameter passing.

   Attempting to QUIT (implicitly or  explicitly)  from  code  invoked  by  a
   DO,  XECUTE  or  extrinsic  after  taht  code  issued  a  TSTART  not  yet
   matched by a TCOMMIT, produces an error.

2 Examples
  QUIT Examples

   Example

          DO A
          QUIT
   A      WRITE !,"This is label A"

   The explicit QUIT at the line preceding the  label  A  prevents  line  A
   from executing twice. The sub-routine at  line  A  terminates  with  the
   implicit QUIT at the end of the routine.

   Example

          WRITE $$ESV
          QUIT
   ESV()
          QUIT "value of this Extrinsic Special Variable"

   Because the label ESV has an  argument  list  (which  is  empty),  MUMPS
   can only legally reach that  label  with  a  extrinsic  invocation.  The
   QUIT  on  the  second   line   prevents   execution   from   erroneously
   "falling through" to the  line  labelled  ESV.  Because  ESV  identifies
   a  subroutine  that  implements  an  extrinsic  special  variable,   the
   QUIT on the line after ESV has an  argument  to  provide  the  value  of
   the extrinsic.

   Example

          S x="" F  s x=$O(^bal(x)) Q:x]"AR5999"!'$L(x)  D STF

   The postconditional QUIT terminates the FOR loop.

1 READ
  R[EAD]
   The READ command transfers input from  the  current  device  to  a  global
   or local variable specified  as  a  READ  argument.For  convenience,  READ
   also  accepts  arguments  that  perform  limited  output  to  the  current
   device.

   The format of the READ command is:

   R[EAD][:tvexpr] glvn|*glvn|lvn#intexpr|strlit|fcc[,...]

   o   The  optional  truth-valued  expression  immediately   following   the
       command is a  command  postconditional  which  controls  whether  GT.M
       executes the command or not

   o   A  subscripted  or  unsubscripted  global  or  local   variable   name
       specifies a variable in which to store the input;  the  variable  does
       not have to exist prior to  the  READ;  if  the  variable  does  exist
       prior to the READ, the READ replaces its old value

   o   When an asterisk (*) immediately  precedes  the  variable  name,  READ
       accepts one character of input and places  the  ASCII  code  for  that
       character in the variable

   o   When a number-sign (#) and an integer  expression  immediately  follow
       the variable name,  the  integer  expression  determines  the  maximum
       number of characters  accepted  as  input  to  the  read;  such  reads
       terminate when MUMPS reads  the  integer  expression  character  or  a
       terminator character in the input stream

   o   To provide a concise means of  issuing  prompts,  MUMPS  sends  string
       literal and format control character  (!,?intexpr,#)  arguments  of  a
       READ to the current device as if they were arguments of a WRITE

   o   An indirection operator and an expression atom evaluating  to  a  list
       of one or more READ arguments form a legal argument for a READ

   The maximum length of the input  string  is  the  smaller  of  the  device
   buffer  size  limitation  or  the  GT.M  maximum  string  length   (32,767
   characters). If a  record  is  longer  than  the  maximum  record  length,
   GT.M returns the record  piece  by  piece  during  sequential  reads,  for
   devices that allow it.

   When a string literal appears as an  argument  to  a  READ,  MUMPS  writes
   the literal  to  the  current  device.  String  literals  appear  as  READ
   arguments  to  serve  as  prompts  for  input.  MUMPS  does   not   permit
   expression arguments on  a  READ  to  act  as  prompts.  Variable  prompts
   must appear as  arguments  to  a  WRITE.  If  a  variable  appears  as  an
   argument to a  READ,  MUMPS  always  interprets  it  as  input,  never  as
   output. This facility is used mostly with terminal I/O.

   The READ commands adjust $X and $Y, based  on  the  length  of  the  input
   read.

2 One_char
  READ *
   The READ * command reads one  character  from  the  current  device  and
   returns the decimal ASCII representation  of  that  character  into  the
   variable  specified  for  the  READ  *  command.  READ  *  appears  most
   frequently  in  communication  protocols,  or  in  interactive  programs
   where single character answers are appropriate.

   The following example reads the  value  "A",  and  returns  the  decimal
   ASCII representation of "A" in the variable X.

   Example

   GTM> READ *X
   A
   GTM> WRITE X
   65
   
   If  a  timeout  occurs  before  GT.M  reads  a  character,  the  READ  *
   returns a negative one (-1) in the variable.

2 Max_length
  READ X#maxlen Command
   The READ X#maxlen command limits the maximum size  of  the  input  to  a
   maximum  of  "maxlen"   characters,   where   maxlen   is   an   integer
   expression.

   If a READ  follows  a  READ  X#maxlen  command,  the  READ  returns  the
   remainder of the current record.

1 RUN_from_the_Shell
  Executing from the Shell
   You  can  run  a  program  from  the  shell  prompt  using  the  following
   command:

   Example

   $ mumps -r "^PAYROLL"



1 SET
  Set Command
   SET  assigns  values  to  variables  or  to  a  selected  portion   of   a
   variable.

   The format of the SET command is:

   S[ET][:tvexpr] glvn|$PIECE()|(glvn[,...])=expr[,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    A subscripted or unsubscripted local or global variable name  on  the
        left of the equal-sign (=) specifies a variable  in  which  to  store
        the expression found on the right of  the  equal-sign;  the  variable
        does not have to exist prior to  the  SET;  if  the  variable  exists
        prior to the SET, the SET replaces its old value

   o    During a SET, MUMPS evaluates the  right  of  the  equal-sign  before
        the  left;  this  is   an   exception   to   the   almost   universal
        left-to-right order of evaluation  in  MUMPS  and  means  that  MUMPS
        maintains  the  naked  indicator  using   the   expression   on   the
        right-hand side of the equal-sign (=) before setting the variable

   o    When the portion of the argument to the left  of  the  equal-sign  is
        in the form of a list  of  variables  enclosed  in  parentheses,  SET
        assigns all the variables the value of the expression  on  the  right
        of the equal-sign

   o    When the portion of the argument to the left  of  the  equal-sign  is
        in the form of a $PIECE function, SET replaces  the  specified  piece
        or pieces of the variable (specified as the  first  argument  to  the
        $PIECE() form) with the expression on the right  of  the  equal-sign;
        if the variable  does  not  exist  prior  to  the  SET  or  does  not
        currently contain the pieces identified by  the  optional  third  and
        fourth arguments to the $PIECE() form, SET  adds  sufficient  leading
        delimiters (specified by the second argument to the $PIECE  form)  to
        make the assignment fit the $PIECE() form

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more SET arguments form a legal argument for a SET

   Because MUMPS does not require  predeclaration  or  typing  of  variables,
   a SET with proper syntax always succeeds regardless  of  the  prior  state
   or value of the variable, as long as MUMPS  can  evaluate  the  expression
   to the right of the equal-sign (=).

   For more information on syntax for  $PIECE(),  refer  to  the  "Functions"
   chapter in the GT.M Programmer's Guide.

2 Examples
  SET Examples

   Example

   GTM> KILL  SET a="x",(b,c)=1,@a="hello" ZWRITE
   a=x
   b=1
   c=1
   x="hello"

   GTM>

   The  KILL  command  deletes  any  previously  defined  local  variables.
   The  SET  command  has  three  arguments.  The  first  shows  a   simple
   direct assignment. The second shows  the  form  that  assigns  the  same
   value to multiple variables.  The  third  shows  atomic  indirection  on
   the left of the equal-sign. The  ZWRITE  command  displays  the  results
   of the assignments.

   Example

   GTM> SET ^(3,4)=^X(1,2)

   Because  MUMPS  evaluates  the  right-hand  side  of   the   equals-sign
   before the  left-hand  side  within  a  SET  argument,  the  right  hand
   expression  determines  the   naked   reference   indicator   prior   to
   evaluation of  the  left-hand  side.  Therefore,  this  example  assigns
   ^X(1,3,4) the value of ^X(1,2).

   Example

   GTM> KILL x SET $P(x,"^",3)="piece 2" ZWRITE x
   x="^^piece 2"

   GTM>

   This  SET  demonstrates  a  "setpiece"  and  shows  how  SET   generates
   missing  delimiters  when  required.  For  more  information  on  syntax
   for  $PIECE(),  refer  to  the   "Functions"   chapter   in   the   GT.M
   Programmer's Guide.

1 Special_Variables
  Intrinsic Special Variables
   MUMPS Intrinsic Special Variables start with  a  single  dollar-sign  ($).
   GT.M provides such  variables  for  program  examination.  In  some  cases
   the Intrinsic Special Variables may be set  to  modify  the  corresponding
   part of the environment.

2 $HOROLOG
  $H[OROLOG]
   $H[OROLOG] contains a string value specifying the number of days
   since 31 December, 1840, and  the  number  of  seconds  since  midnight,
   separated by a comma (,).

   At midnight, the second piece of the  string  resets  to  zero  (0)  and
   the first piece increments by one (1).

   Example

   GTM> WRITE $HOROLOG

   Produces the result 55555,55555 at 3:25:55 pm on 7 February, 1993.

   For  further  information  on  formatting  $HOROLOG  for  external  use,
   see the section on $ZDATE()  in  the  "Commands"  chapter  of  the  GT.M
   Programmer's Guide.

2 $IO
  $IO
   $I[O] contains the name of the current device as specified by the
   last USE command. The MUMPS standard  does  not  permit  a  SET  command
   to  modify  $IO.  USE  0  and  USE  ""  produce  the  same  $IO  as  USE
   $PRINCIPAL.

2 $JOB
  $J[OB]
   $J[OB] contains the current process identifier.

   $JOB is guaranteed to be unique for every concurrently operating
   process on a system.

   Example

   LOOP0  F  S itm=$O(^tmp($J,itm)) Q:itm=""  D LOOP1

   This uses $J as the first subscript in  a  temporary  global  to  insure
   that every process uses  separate  data  space  in  that  global,  i.e.,
   that no two concurrent processes use the same part of ^tmp.

2 $PRINCIPAL
  $P[RINCIPAL]
   $P[RINCIPAL] contains the absolute pathname of the principal
   (initial $IO) device.  $PRINCIPAL  is  an  MDC  type  A  enhancement  to
   standard MUMPS.

2 $STORAGE
  $S[TORAGE]
   $S[TORAGE] contains an integer value specifying the number of free
   bytes of address space remaining  between  the  memory  currently  under
   management by the process  and  the  theoretical  maximum  available  to
   the process.

   GT.M uses memory for code (instructions) and data.

   Instruction  space  starts  out  with  the  original  executable  image.
   However, GT.M  may  expand  instruction  space  by  ZLINKing  additional
   routines.

   Data space starts  out  with  stack  space,  which  never  expands,  and
   pool space, which may expand. Operations  such  as  opening  a  database
   or creating a local variable may  cause  an  expansion  in  pool  space.
   GT.M expands pool space in  fairly  large  increments.  Therefore,  SETs
   of local variables may not affect  $STORAGE  at  all  or  may  cause  an
   apparently disproportionate drop in its value.

   Once a GT.M process adds either instruction  or  data  space,  it  never
   releases that  space.  However,  GT.M  does  reuse  process  space  made
   available by actions such as KILLs of local variables.

2 $TEST
  $T[EST]
   $T[EST] contains a truth value specifying the evaluation of the
   last IF argument or  the  result  of  the  last  timed  operation.  When
   the  last  such  operation  timed  out,   $TEST   contains   zero   (0);
   otherwise, it contains one (1).

   $TEST serves as the implicit argument for ELSE commands and
   argumentless IF commands.

   MUMPS stacks $TEST  when  invoking  an  extrinsic  and  when  performing
   an  argumentless  DO.  After   these   operations   complete   with   an
   implicit or explicit QUIT,  MUMPS  restores  the  corresponding  stacked
   value. Because, with these  two  exceptions,  $TEST  reflects  the  last
   IF argument or timeout  result  on  a  process  wide  basis,  use  $TEST
   only in immediate proximity to the operation that last updated it.

2 $TLEVEL
  $TL[EVEL]
   $TL[EVEL] contains a count of executed TSTARTs that are cuurently
   unmatched  by  TCOMMITs.  $TLEVEL  is  zero  (0)  when   there   is   no
   TRANSACTION in progress. When $TLEVEL  is  greater  than  one  (>1),  it
   indicates that there  are  nested  sub-transactions  in  progress.  Sub-
   transactions  are  always  subject  to  the  completion  of   the   main
   TRANSACTION  and  cannot  be  independently  acted   upon   by   COMMIT,
   ROLLBACK or RESTART.

   $TLEVEL can be used to determine whether there is a TRANSACTION in
   progress and to determine the level of nesting of sub-transactions.

2 $TRESTART
  $TR[ESTART]
   $TR[ESTART] contains a count of the number of times that the
   current   TRANSACTION   has   been   RESTARTed.   When   there   is   no
   TRANSACTION in progress, $TRESTART is zero (0).

   $TRESTART can be used to limit the number of RESTARTs, or to cause
   a routine to perform different actions  during  a  RESTART  than  during
   the initial execution.

2 $X
  $X
   $X contains an integer value ranging from 0 to 65,535, specifying
   the horizontal position of  a  virtual  cursor  in  the  current  output
   record. $X=0 represents the left-most position of a record or row.

   Every OPEN device has a $X. However,  MUMPS  only  accesses  $X  of  the
   current device. Therefore, exercise  care  in  sequencing  USE  commands
   and references to $X.

   Generally, GT.M  increments  $X  for  every  character  written  to  and
   read  from  the  current  device.  MUMPS  format   control   characters,
   write filtering, and the device WIDTH also have an effect on $X.

   GT.M  follows  the  MDC  Type  A  recommendation  and  permits  a  MUMPS
   routine to  SET  $X.  However,  SET  $X  does  not  automatically  issue
   device  commands  or  escape  sequences  to  reposition   the   physical
   cursor.

2 $Y
  $Y
   $Y contains an integer value ranging from 0 to 65,535 specifying
   the vertical  position  of  a  virtual  cursor  in  the  current  output
   page. $Y=0 represents the top row or line.

   Every OPEN device has a $Y. However,  MUMPS  only  accesses  $Y  of  the
   current device. Therefore, exercise  care  in  sequencing  USE  commands
   and references to $Y.

   When  GT.M  finishes  the  logical  record  in  progress,  it  generally
   increments $Y. GT.M recognizes the end  of  a  logical  record  when  it
   processes  certain  MUMPS  format  control  characters,  or   when   the
   record reaches its maximum size, as  determined  by  the  device  WIDTH,
   and the device is set  to  WRAP.  The  definition  of  "logical  record"
   varies  from  device  to  device.  For  an  exact  definition,  see  the
   sections on each device type. Write  filtering  and  the  device  LENGTH
   also have an effect on $Y.

   GT.M permits a MUMPS routine  to  SET  $Y.  However,  SET  $Y  does  not
   automatically   issue   device   commands   or   escape   sequences   to
   reposition the physical cursor.

2 $ZCSTATUS
  $ZDCSTATUS
   $ZCSTATUS holds the value of the status code for the last compile
   performed by a ZCOMPILE command.

2 $ZDIRECTORY
  $ZDIR[ECTORY]
   $ZDIR[ECTORY] contains a string value of the current directory at
   the time when the GT.M image was activated.

   MUMPS routines cannot modify $ZDIRECTORY.

   Example

   GTM> WRITE $ZDIR
   /usr/dev/mydir

   This displays the current default directory.

   Example

   GTM> S where=$ZPARSE("dummy","DEVICE")_$ZDIR

   This  assigns   where   the   process   current   default   device   and
   directory.

2 $ZEDIT
  $ZEDIT
   $ZEDIT holds the value of the status code for the last edit session
   invoked by a ZEDIT command.

2 $ZEOF
  $ZEOF
   $ZEOF contains a truth-valued expression indicating whether the
   last READ operation  reached  the  end-of-file.  $ZEOF  equals  one  (1)
   at EOF and zero (0) at other positions.

   GT.M does not maintain $ZEOF for terminal devices.

   $ZEOF refers to the end-of-file status of the current device.
   Therefore, exercise care  in  sequencing  USE  commands  and  references
   to $ZEOF.

2 $ZGBLDIR
  $ZGBL[DIR]
   $zgbldir contains the value of the current Global Directory
   filename. When $zgbldir  specifies  an  invalid  or  inaccessible  file,
   GT.M cannot successfully perform database operations.

   GT.M  initializes  $zgbldir  to  the  translation  of  the   environment
   variable  gtmgbldir.  If  gtmgbldir  is  not  defined,  GTM  initializes
   $zgbldir to null. When $zgbldir is null, GT.M constructs a filename
   for the Global Directory using the  name  gtmgbldir  and  the  extension
   .GLD  in  the  process  current  default  directory.  A  $zgbldir  value
   may include an environment variable.

   $zgbldir is a read-write Intrinsic Special Variable, i.e., it can
   appear on the left-hand side of  the  equal-sign  (=)  in  the  argument
   to a SET command. SET $zgbldir="" causes  GT.M  to  assign  $zgbldir  to
   the  translation  of  gtmgbldir  if   that   environment   variable   is
   defined. If gtmgbldir  is  not  defined,  then  SET  $zgbldir=""  causes
   GT.M to assign  the  string  "gtmgbldir"  to  $zgbldir.  This  specifies
   the file gtmgbldir.gld in the current directory.

   SETting $zgbldir also causes GT.M  to  attempt  to  open  the  specified
   file. If the filename is invalid  or  the  file  is  inaccessible,  GT.M
   reports  an  informational  error  and   continues   execution   without
   changing the value of $zgbldir.

   To  establish  a  value  for  $zgbldir  outside  of   MUMPS,   use   the
   appropriate  shell  command  to  assign  a  translation  to   gtmgbldir.
   Defining gtmgbldir provides a convenient way  to  use  the  same  Global
   Directory during  a  session  where  you  repeatedly  invoke  and  leave
   GT.M. Changes  to  the  value  of  $zgbldir  during  a  GT.M  invocation
   only last for the current invocation and do  not  change  the  value  of
   gtmgbldir.

3 Examples
  $ZGBLDIR Example

   Example

   $ gtmgbldir=test.gld
   $ GTM
   GTM> WRITE $zgbldir
   TEST.GLD
   GTM> SET $zgbldir="MUMPS.GLD"
   GTM> WRITE $zgbldir
   MUMPS.GLD
   GTM> HALT
   $ echo $gtmgbldir
   TEST.GLD

   This defines  the  logical  name,  gtmgbldir.  In  GT.M  Direct  Mode,
   $zgbldir has the value supplied by gtmgbldir. The SET command
   changes  the  value.  After  the  GT.M  image  terminates,  the   echo
   command  demonstrates  that  gtmgbldir  was  not   modified   by   the
   MUMPS SET command.

   Example

   $ ls test.gld
   test.gld: No such file or directory
   $ GTM
   GTM> W $zgbldir
   /usr/dev/jjs/mumps.gld
   GTM> SET $zgbldir="TEST.GLD"
   Cannot access global directory "TEST.GLD".
    Continuing with "/usr/dev/jjs/mumps.gld"
   $zgbldir
   /usr/dev/jjs/mumps.gld
   GTM> HALT
   $

   The  SET  command  attempts  to  change  the  value  of  $zgbldir   to
   "TEST.GLD", but because the file  does  not  exist,  GT.M  reports  an
   error and does not change the value of $zgbldir.

2 $ZIO
  $ZIO
   $ZIO contains the translated name of the current device, in
   contrast to $IO, which  contains  the  name  as  specified  by  the  USE
   command.

2 $ZLEVEL
  $ZL[EVEL]
   $ZL[EVEL] contains an integer value indicating the "level of
   nesting"  caused  by  DO  commands,  XECUTE   commands   and   extrinsic
   functions in the MUMPS virtual stack.

   $ZLEVEL has an initial value of one (1) and increments by one with
   each  DO,  XECUTE  or  extrinsic  function.  Any  QUIT  that  does   not
   terminate  a  FOR  loop  decrements  $ZLEVEL.  ZGOTO  may  also   reduce
   $ZLEVEL. In accordance with the MUMPS standard, a FOR command does
   not increase $ZLEVEL. MUMPS routines  cannot  modify  $ZLEVEL  with  the
   SET or KILL commands.

   Use  $ZLEVEL  in  debugging  or  in  an  error-handling   mechanism   to
   capture a level for later use in a ZGOTO argument.

3 Example
  $ZLEVEL Example

   Example

   GTM> ZPRINT ^ZLEV
   A      DO B
          WRITE X,!
          QUIT
   B      GOTO C
          QUIT
   C      DO D
          QUIT
   D      SET X=$ZLEVEL
          QUIT
   GTM> DO ^ZLEV
   4

   This program, executed  from  Direct  Mode,  produces  a  value  of  4
   for $ZLEVEL. Note  that  if  we  run  this  program  from  the  shell,
   the value of $ZLEVEL is three (3).

2 $ZPOSITION
  $ZPOS[ITION]
   $ZPOS[ITION] contains a string value specifying the current
   entryref,  where  entryref   is   [label][+offset][^routine]   and   the
   offset is evaluated from the closest preceding label.

   MUMPS  routines  cannot  modify  $ZPOSITION  with  the   SET   or   KILL
   commands.

   Example

   GTM> WRITE !,$ZPOS,! ZPRINT @$ZPOS

   This displays the current location  followed  by  the  source  code  for
   that line.

2 $ZPROMPT
  $ZPROMP[T]
   $ZPROMP[T] contains a string value specifying the current Direct
   Mode prompt.

   $ZPROMPT cannot exceed 16 characters. By default, Direct Mode
   prompts with GTM> .

   Example

   GTM> S $ZPROMPT=$P($P($ZDIR,".",$L($ZDIR,".")),"]")_"> "
   ROUTINES>

   This changes the prompt to display  the  name  of  the  current  default
   directory (without its ancestors).

2 $ZROUTINES
  $ZRO[UTINES]
   $zroutines contains a string value specifying a directory or list
   of directories  containing  object  files.  Each  object  directory  may
   also  have  an   associated   directory,   or   list   of   directories,
   containing  the  corresponding  source  files.  These  directory   lists
   are used by certain GT.M  functions,  primarily  auto-ZLINK,  to  locate
   object and source files. The order in  which  directories  appear  in  a
   given list determines the order in  which  they  are  searched  for  the
   appropriate item.

   Searches that use $zroutines treat files  as  either  object  or  source
   files. GT.M treats files with a type of  .o  as  object  files  and  all
   other files as source files.  Source  files  must  always  have  a  file
   extension of .m.

   When   the   environment   variable   gtmroutines   is   defined,   GT.M
   initializes   $zroutines   to   the    translation    of    gtmroutines.
   Otherwise, GT.M initializes  $zroutines  to  null.  When  $zroutines  is
   null, GT.M attempts to  locate  all  source  and  object  files  in  the
   process  current  default  directory.  $zroutines=""  is  equivalent  to
   $zroutines=".".

   Commands or functions such  as  DO,  GOTO,  ZGOTO,  ZBREAK,  ZPRINT  and
   $TEXT may auto-ZLINK and thereby indirectly use $zroutines. If
   their  argument  does  not  specify  a  directory,  ZEDIT  and  explicit
   ZLINK use $zroutines.  ZPRINT and  $TEXT  use  $zroutines  to  locate  a
   source file if GT.M cannot find  the  source  file  pointed  to  by  the
   object file. For more information on  ZLINK  and  auto-ZLINK,  refer  to
   the "Commands" chapter in the GT.M Programmer's Guide.

   $zroutines is a read-write Intrinsic Special Variable, which MUMPS
   can SET as well as reference. A $zroutines  value  must  have  the  form
   of a list of directories delimited by spaces.

3 Environment_variables
  $ZROUTINES and Environment Variables
   Directory  specifications  may  include   an   environment   variable.
   When   GT.M   SETs   $zroutines,   it   translates   all   environment
   variables  and  verifies  the  syntax  and  the   existence   of   all
   specified directories. If $zroutines  is  set  to  an  invalid  value,
   GT.M generates a run-time error and  does  not  change  the  value  of
   $zroutines. Because the environment variables are translated
   when $zroutines is set,  any  changes  to  their  definition  have  no
   effect until $zroutines is next set.

3 File-specs
  $zroutines File-specifications
   By  default,  each  directory  entry  in  $zroutines  is  assumed   to
   contain  both  object  and  source   files.   However,   each   object
   directory   may   have   an   associated   directory   or   list    of
   directories  in  which  to  search  for   the   corresponding   source
   files. This is  done  by  specifying  the  source  directory  list  in
   parentheses,   immediately   after   the   appropriate   object   file
   directory specification.  If  the  command  specifies  more  than  one
   directory, the  directories  must  be  separated  by  spaces  and  the
   entire  list  must  be  enclosed  in  parentheses  ()  following   the
   object   directory   specification.   If   a   directory   should   be
   searched for source, the name  of  that  directory  must  be  included
   in the  parentheses,  usually  as  the  first  element  in  the  list.
   Directory-specifications   may   also   include   empty   parentheses,
   directing  GT.M  to  proceed  as  if  no  source   files   exist   for
   objects located in the qualified directory.

3 Examples
  $zroutines Examples

   Example

   s $zroutines=".(../src) $gtm_dist"

   This  directs  GTM  to  look  for  routines  first  in  your   current
   directory,  then  in  the  distribution  directory,   which   contains
   the percent routines.

   Example
   $ gtmroutines="/users/jones /users/smith"
   $ export gtmroutines
   GTM> write $zroutines
   "/users/jones /users/smith"
   GTM> set $zro="/users/jones/utl /users/smith/utl"
   GTM> write $zroutines
   "/users/jones/utl /users/smit/utl"
   GTM> halt
   $ echo gtmroutines
   /user/jones /user/smith

   This  defines  the  environment   variable   gtmroutines.   In   GT.M,
   $zroutines has the value supplied by gtmroutines. The SET
   command changes  the  value.  When  the  GT.M  image  terminates,  the
   shell  echo  command  demonstrates  that  gtmroutines  has  not   been
   modified by the MUMPS SET command.

   Example

   GTM> S $ZRO=. /user/smith"

   This sets $zroutines to a list containing two directories.

   Example

   GTM> set $zro="/user/smith (/user/smith/tax /user/smith/fica)"

   This specifies that  GT.M  should  search  the  directory  /user/smith
   for   object   files   and   the   directories   /user/smith/tax   and
   /user/smith/fica  for  source  files.  Note  that  in  this   example,
   GT.M does not search /user/smith for source files.

   Example

   GTM> s $zro="/usr/smith (/usr/smith /usr/smith/tax
   /usr/smith/fica)"

   This specifies  that  GT.M  should  search  the  directory  /usr/smith
   for   object   files   and   the   directories   /usr/smith/tax    and
   /usr/smith/fica  for  source   files.   Note   that   the   difference
   between this example and  the  previous  one  is  that  GT.M  searches
   /usr/smith for both object and source files.

   Example

   GTM> set $zro="/user/smith /user/smith/tax() /user/smith/fica"

   This   specifies   that   GT.M   should   search    /user/smith    and
   /user/smith/fica  for  object  and  source  files.  However,   because
   the  empty  parentheses  indicate  directories   searched   only   for
   object  files,  GT.M  does  not  search  /user/smith/tax  for   source
   files.

   Omission of the  parentheses  altogether  indicates  GT.M  can  search
   the    directory    for    both    source    and     object     files.
   $zroutines="/user/smith" is equivalent to
   $zroutines="/user/smith (/user/smith)"

3 Searches
  $zroutines Search Types
   GT.M uses $zroutines to perform three types of searches:

   o  Object-only  when  the  command  or   function   using   $zroutines
      requires a .o file extension

   o  Source-only  when  the  command  or   function   using   $zroutines
      requires a file extension other than .o

   o  Object-source  match   when   the   command   or   function   using
      $zroutines does not specify a file extension

   All searches  proceed  from  left  to  right  through  $zroutines.  By
   default,  GT.M  searches  directories  for  both  source  and   object
   files.  GT.M  searches  directories  followed  by  empty   parentheses
   () only for  object  files.  GT.M  searches  directories  followed  by
   directory specifications in parenthesesonly for source files.

   Once  an  object-matching  search  locates   an   object   file,   the
   source  search  becomes  limited.  If  the  directory  containing  the
   object  file  has  an  attached  list  of   directories,   GT.M   only
   searches  the  directories  in  the   attached   list   for   matching
   source files. If  the  directory  containing  the  object  files  does
   not  specify  any  source  directories,  GT.M  restricts  the   search
   for matching source  files  to  the  same  directory.  If  the  object
   module  is  in  an  object  library,  or  a  directory  qualified   by
   empty  parentheses,   GT.M   cannot   perform   any   operation   that
   references the source file.

   If ZPRINT or $TEXT require a source  module  for  a  routine  that  is
   not in the current image, GT.M first performs an auto-ZLINK.

   ZPRINT  or   $TEXT   locate   the   source   module   using   a   file
   specification for the  source  file  located  in  the  object  module.
   If GT.M finds  the  source  module  in  the  directory  where  it  was
   when  it  was   compiled,   the   run-time   system   does   not   use
   $zroutines. If GT.M locates the source module, but finds it
   inaccessible because of  security,  the  run-time  system  signals  an
   error  and  does  not  use  $zroutines.  If  GT.M  cannot   find   the
   source file in  the  indicated  location,  the  run-time  system  uses
   $zroutines.

2 $ZSOURCE
  $ZSO[URCE]
   $ZSO[URCE] contains a string value specifying the default filename
   for the ZEDIT and ZLINK commands.

   $ZSOURCE initially contains the null string. When ZEDIT and ZLINK
   commands have an argument, they implicitly  set  $ZSOURCE  to  the  name
   of the specified file.  The  filename  may  contain  a  file  extension.
   ZEDIT  or  ZLINK  without  an  argument  is  equivalent  to  ZEDIT/ZLINK
   $ZSOURCE.

   $ZSOURCE is a read-write Intrinsic Special Variable, i.e., it can
   appear on the left-hand side of  the  equal-sign  (=)  in  the  argument
   to  a  SET  command.  A  $ZSOURCE  value  may  include   an   evironment
   variable.


3 Examples
  $ZSOURCE Examples

   Example

   GTM> ZEDIT "SUBR.M"
        .
        .
        .
   GTM> WRITE $ZSOURCE
   SUBR

   Example

   GTM> ZEDIT "TEST"
        .
        .
        .
   GTM> WRITE $ZSOURCE
   TEST

   Example

   GTM> ZEDIT "/usr/smith/report.txt"
        .
        .
        .
   GTM> WRITE $ZSOURCE
   /usr/smith/report.txt

   Example

   GTM> ZLINK "BASE..o"
        .
        .
        .
   GTM> WRITE $ZSOURCE
   BASE


2 $ZSTATUS
  $ZS[TATUS]
   $ZS[TATUS] contains a string value specifying the error condition
   code  and  location  of  the  last  exception  condition  that  occurred
   during routine execution.

   GT.M maintains  $ZSTATUS  as  a  string  consisting  of  three  or  more
   substrings. The string consists of:

   o   An error message number as the first substring

   o   The entryref of the  line  in  error  as  the  second  substring;  a
       comma separates the first and second substrings

   o   One or more error  message  text  substrings;  a  percent  sign  (%)
       identifies  the  first  text  substring;  a  hyphen  (-)  identifies
       each of the remaining text substrings

   GT.M  sets  $ZSTATUS  when   it   encounters   errors   during   program
   execution,  but  not  when  it  encounters  errors  in  a  Direct   Mode
   command.

   MUMPS  routines  cannot  modify  $ZSTATUS   with   the   SET   or   KILL
   commands.

3 Example
  $ZSTATUS Example

   Example

   GTM> WRITE $ZSTATUS
   15037310,+1^MYFILE,%GTM-E-DIVZERO, Attempt to divide by zero

   This displays the status generated by a divide by zero (0).

2 $ZSYSTEM
  $ZSYSTEM
   $ZSYSTEM holds the value of the status code for the last subprocess
   invoked with the ZSYSTEM command.

2 $ZTRAP
  $ZT[RAP]
   $ZT[RAP] contains a string value that GT.M XECUTEs when an error
   occurs during routine execution.

   When the  $ZTRAP  variable  is  not  null,  GT.M  performs  an  implicit
   "XECUTE $ZTRAP" upon  a  process  exception.  The  $ZTRAP  variable  has
   the initial value  of  "B",  which  puts  the  process  in  Direct  Mode
   when an  error  condition  occurs.  If  the  value  of  $ZTRAP  is  null
   (""), an exception causes the  image  to  run-down  with  the  condition
   code  associated  with  the  exception.  If  $ZTRAP   contains   invalid
   source code, GT.M  displays  an  error  message  and  puts  the  process
   into Direct Mode.

   $ZTRAP is a read-write Intrinsic Special Variable, i.e., it can
   appear on the left-hand side of  the  equal-sign  (=)  in  the  argument
   to a SET command.

   $ZTRAP may also appear as an argument to an inclusive NEW command.
   NEW $ZTRAP causes  GT.M  to  set  $ZTRAP  to  null  ($ZTRAP="")  and  to
   stack the  old  value  of  $ZTRAP.  When  the  program  QUITs  from  the
   invocation level  where  the  NEW  occurred,  GT.M  restores  the  value
   previously  stacked  by  the  NEW.  NEW  $ZTRAP  provides   nesting   of
   $ZTRAP. Because $ZTRAP="" terminates the image when an error
   occurs, SET $ZTRAP= generally  follows  immediately  after  NEW  $ZTRAP.
   You may use  this  technique  to  construct  error  handling  strategies
   corresponding to the nesting of your programs.

   Keep $ZTRAP simple and put complicated  logic  in  another  routine.  If
   the action  specified  by  $ZTRAP  results  in  another  run-time  error
   before  changing  the  value  of  $ZTRAP,   GT.M   iteratively   invokes
   $ZTRAP until it exhausts the process stack space, terminating the
   image.  Take  special  care  to  debug  exception  handling.  For   more
   information  on  error  handling,  refer  to  the  "Processing   Errors"
   chapter of the GT.M Programmer's Guide.

3 Example
  $ZTRAP Example

   Example

   GTM> S $ZTRAP="ZP @$ZPOS B"

   This modifies $ZTRAP  to  display  source  code  for  the  line  where
   GT.M encounters an error before entering Direct Mode.

2 $ZVERSION
  $ZVER[SION]
   $ZVER[SION] contains a string value specifying the current GT.M
   version.

   MUMPS routines cannot modify $ZVERSION.

   Example

   GTM> WRITE $ZVERSION
   xxx Vn.n-n

   This  displays  the  current  version  version  identifier   for   GT.M,
   where xxx is an  acronym  representing  the  system  currently  in  use,
   and Vn.n-n gives the version and release number.

1 TCOMMIT
  TCOMMIT Command
   The TCOMMIT command marks the end  of  a  TRANSACTION  or  sub-transaction
   and decrements  $TLEVEL.  If  TCOMMIT  marks  the  end  of  a  TRANSACTION
   (decrements $TLEVEL  to  zero),  it  causes  a  COMMIT,  which  makes  the
   database  updates  performed  by  the  TRANSACTION  available.  A  TCOMMIT
   when no TRANSACTION is in progress ($TLEVEL=0) produces an error.

   The format of the TCOMMIT command is:

   TC[OMMIT] [:tvexpr]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a command postconditional that  controls  whether  or  not
        MUMPS executes the command.

   o    Because the TCOMMIT has no argument, at least  two  (2)  spaces  must
        follow the command to separate  it  from  the  next  command  on  the
        line.

   For an example of the use of the TCOMMIT command,  refer  to  the  chapter
   on "General Features" in the GT.M Programmer's Guide.

1 TRESTART
  TRESTART Command
   The TRESTART command  attempts  to  RESTART  the  current  TRANSACTION.  A
   RESTART transfers control back to the initial  TSTART  and  restores  much
   of  the  process  state  to  what  it  was  when  that  TSTART  was  first
   executed. If the TRANSACTION does not have  RESTART  enabled,  a  TRESTART
   causes  an  error.  A  TRESTART  when  no  TRANSACTION  is   in   progress
   ($TLEVEL=0) produces an error.

   The format for the TRESTART command is:

   TRE[START] [:tvexpr]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a command postconditional that  controls  whether  or  not
        MUMPS executes the command.
   o    Because the TRESTART has no argument, at least two  (2)  spaces  must
        follow the command to separate  it  from  the  next  command  on  the
        line.

   TRESTART (and implicitly  RESTARTs)  do  not  restore  any  device  state;
   they do restore the following to the  state  they  had  when  MUMPS  first
   executed the initial TSTART:

   o    $TEST

   o    The naked indicator

   o    LOCKs held by the process

   They also restore  any  local  variables  named  by  one  or  more  active
   TSTARTs to the values that each had when they were first named.

   For an  example  of  the  use  of  the  TRESTART  command,  refer  to  the
   chapter on "General Features" in the GT.M Programmer's Guide.

1 TROLLBACK
  TROLLBACK Command
   The TROLLBACK command terminates a  TRANSACTION  by  causing  a  ROLLBACK,
   which  removes  all  database  updates  performed  within  a  TRANSACTION.
   TROLLBACK also sets  $TLEVEL  and  $TRESTART  to  zero  (0).  A  TROLLBACK
   when no TRANSACTION is in progress ($TLEVEL=0) produces an error.

   The format of the TROLLBACK command is:

   TRO[LLBACK] [:tvexpr]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a command postconditional that  controls  whether  or  not
        MUMPS executes the command.

   o    Because the TROLLBACK has no argument, at least two (2)  spaces  must
        follow the command to separate  it  from  the  next  command  on  the
        line.

   In order  to  allow  for  error  recovery  and/or  access  to  the  global
   context  of  the  error,  errors  do   not   cause   implicit   ROLLBACKs.
   Therefore,  the  code   for   handling   errors   during   any   and   all
   TRANSACTIONs  should  generally   include   a   TROLLBACK.   Because   the
   TROLLBACK releases resources held by the  TRANSACTION,  it  should  appear
   as early as possible in the error handling code.

   For an example  of  the  use  of  the  TROLLBACK  command,  refer  to  the
   chapter on "General Features" in the GT.M Programmer's Guide.

1 TSTART
  TSTART Command
   A TSTART command marks the  start  of  a  TRANSACTION  or  sub-transaction
   and  increments  $TLEVEL.  When  a  TSTART  starts  a   TRANSACTION,   its
   arguments determine  whether  the  TRANSACTION  may  RESTART  and  whether
   serializability is enforced by LOCK commands or,  if  the  SERIAL  keyword
   is  specified,  by  MUMPS.  If  a  TRANSACTION  may  RESTART,  the  TSTART
   arguments  determine  which  local  variables  are   restored   during   a
   RESTART.

   The format of the TSTART command is:

   TS[TART] [:tvexpr] [([lname...])|lname|*|][:keyword|(keyword...)]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a command postconditional that  controls  whether  or  not
        MUMPS executes the command.

   o    If $TLEVEL is 0 before the TSTART, the TSTART starts  a  TRANSACTION;
        otherwise it starts a sub-transaction.

   o    If the TSTART starts a TRANSACTION and the portion  of  the  argument
        before the colon (:) delimiter  is  empty,  the  TRANSACTION  is  not
        eligible for RESTART. If the TSTART  starts  a  TRANSACTION  and  the
        portion  of  the  argument  before  the  colon  is  not  empty,   the
        TRANSACTION  is  eligible  for  RESTART.  If  the  TSTART  is  nested
        (starts a sub-transaction), its arguments have no effect  on  whether
        the TRANSACTION is eligible for RESTART.

   o    If the portion of the argument before the colon is an  asterisk  (*),
        any subsequent RESTART restores all  local  variables  to  the  value
        they have when the TSTART is executed.

   o    If the portion of the argument before the colon is  an  unsubscripted
        local  variable  name  or  a  list  of   such   names   enclosed   in
        parentheses, a RESTART restores the  named  variables  to  the  value
        they had when the TSTART is executed.

   o    If the portion of the argument before the colon is  a  set  of  empty
        parentheses (), a RESTART does not restore any local variables.

   o    The optional portion of the argument after the  colon  is  a  keyword
        or a  colon-separated  list  of  keywords  enclosed  in  parentheses,
        where the keywords specify TRANSACTION characteristics.

   o    An indirection operator  and  an  expression  atom  evaluating  to  a
        TSTART argument form a legal argument for a TSTART.

   A TSTART within a TRANSACTION  does  not  start  a  new  TRANSACTION,  but
   instead starts a sub-transaction. The argument to such  a  TSTART  has  no
   effect on whether the existing TRANSACTION  may  RESTART  or  whether  the
   SERIAL keyword has made  MUMPS  responsible  for  the  serializability  of
   the TRANSACTION. TSTART may add  local  variables  to  be  restored  in  a
   TRANSACTION that  has  RESTART  enabled.  A  nested  TSTART  that  permits
   RESTART  where the  TRANSACTION  does  not,  should  not  cause  problems.
   However,  a  nested  TSTART  that  does  not  permit  RESTART  where   the
   TRANSACTION does, may indicate  that  the  sub-transaction  has  not  been
   coded to properly handle RESTART.

   Sub-transactions cannot COMMIT independently  from  the  TRANSACTION,  nor
   can  they  ROLLBACK  or  RESTART  independently.  Sub-transactions   exist
   largely  as  a   programming   convenience   to   allow   flexibility   in
   organizing code in a modular fashion.

   For an example of the use of the TSTART  command,  refer  to  the  chapter
   on "General Features" in the GT.M Programmer's Guide.

2 S[ERIAL]
  S[ERIAL]
   The   SERIAL   keyword   indicates   that   MUMPS   must   ensure    the
   serializability of the TRANSACTION. When the SERIAL keyword  is  absent,
   the MUMPS program must ensure serializability  by  proper  use  of  LOCK
   commands. On a nested TSTART, this portion of the argument is ignored.

2 T[RANSACTIONID]=expr
  T[RANSACTIONID]=expr
   The   TRANSACTIONID   keyword   declares   an   arbitrary    transaction
   identification.

1 USE
  U[SE]
   The  USE  command  selects  the  current  device  for  READs  (input)  and
   WRITEs (output).

   The format of the USE command is:

   U[SE][:tvexpr] expr[:(keyword[=expr][:...])][,...]

   o   The  optional  truth-valued  expression  immediately   following   the
       command is a  command  postconditional  which  controls  whether  GT.M
       executes the command or not

   o   The required expression specifies  the  device  to  make  the  current
       device

   o   A USE that selects a  device  not  currently  OPENed  by  the  process
       causes a run-time error

   o   The optional keywords specify  deviceparameters  that  control  device
       behavior

   o   If the argument only contains  one  deviceparameter,  the  surrounding
       parentheses are optional

   o   An indirection operator and an expression atom evaluating  to  a  list
       of one or more USE arguments form a legal argument for a USE

   The  intrinsic  special  variable  $IO  identifies  the  current   device.
   MUMPS directs all READs and  WRITEs  to  $IO.  Once  a  GT.M  MUMPS  image
   USEs a device, $IO holds the name  of  that  device  until  the  next  USE
   command. Attempting to USE an unOPENed device  causes  a  run-time  error.
   Note that $PRINCIPAL is implicitly OPENed  and  USEd  when  a  GT.M  image
   starts. The ANSI MUMPS standard  specifies  that  USE  commands  may  come
   in a list, however, this construct does not add  any  useful  facility  to
   MUMPS.

   A  USE  command  modifies  the  device  using  the  deviceparameters  that
   apply to the device type and ignoring  others.  Characteristics  set  with
   USE deviceparameters persist until  another  USE  with  the  corresponding
   deviceparameter. Characteristics persist through  USEs  of  other  devices
   and,  except  for  sequential  files,  through  a  subsequent  CLOSE   and
   re-OPEN.

2 Examples
  USE Examples

   Example

   USE $P:(X=0:Y=$Y-1:NOECHO)

   This USEs the principal device.  If  that  device  is  a  terminal,  the
   deviceparameters  turn  off  echo  and  position  the  cursor   to   the
   beginning of the prior line.

2 CENABLE
  [NO]CENABLE
   Enables or disables the ability  to  force  GT.M  into  Direct  Mode  by
   entering <CTRL C> at $PRINCIPAL.

   [NO]CENABLE  is  subordinate  to  a  CTRAP  that   includes   <CTRL   C>
   ($C(3)).

   By default, images have CENABLEd.

2 CLEARSCREEN
  CLEARSCREEN
   Clears the terminal screen from  the  present  cursor  position  to  the
   bottom  of  the  screen.  The  CLEARSCREEN  deviceparameter   does   not
   change the cursor position or  the  $X  and  $Y  variables.  CLEARSCREEN
   only works on $PRINCIPAL.

   Example:

   U 0:(X=0:Y=0:CLEAR)

   This positions the cursor to "home"  in  the  upper  left  corner  of  a
   VDT and clears the entire current screen "page."

2 CONVERT
  [NO]CONVERT
   Enables  or  disables  the  terminal  device  driver   from   converting
   lowercase input to uppercase during READs.

   By default, the terminal device driver operates NOCONVERT.

2 DOWNSCROLL
  DOWNSCROLL
   If $Y=0,  DOWNSCROLL  does  nothing.  Otherwise,  DOWNSCROLL  moves  the
   cursor up one line on the terminal screen  and  decrements  $Y  by  one.
   DOWNSCROLL does not change the column  position  or  $X.  Some  terminal
   hardware  may  not  support  DOWNSCROLL.  DOWNSCROLL   only   works   on
   $PRINCIPAL.

2 ECHO
  [NO]ECHO
   Enables or disables terminal device driver echo of input.

   By default, terminal device drivers ECHO.

2 ERASELINE
  ERASELINE
   Clears the current  line  from  the  physical  cursor  position  to  the
   end  of  the  line.  ERASELINE  does  not  affect  the  physical  cursor
   position, or $X and $Y. ERASELINE only works on $PRINCIPAL.

2 EXCEPTION
  EXCEPTION=expr
   Defines an  error  handler  for  an  I/O  device.  The  expression  must
   contain a  fragment  of  MUMPS  code  (e.g.,  GOTO  ERRTAPE)  that  GT.M
   XECUTEs when the driver for the device detects an error.

   For more  information  on  error  handling,  refer  to  the  "Processing
   Errors" chapter in the GT.M Programmer's Guide.

2 FILTER
  [NO]FILTER[=expr]
   Specifies   character   filtering   for   terminal   output.   Filtering
   requires  character  by  character  examination  of   all   output   and
   reduces I/O performance.

   Each  FILTER  deviceparameter  can  have  only  one  argument.  However,
   multiple  FILTER  deviceparameters  can   appear   in   a   single   USE
   command, each with different arguments.

   The valid filtering expressions are:

   o    [NO]CHARACTERS  enables  or  disables  maintenance  of  $X  and  $Y
        according to the MUMPS  ANSI  standard  for  the  characters  <BS>,
        <LF>, <CR>  and  <FF>.  CHARACTERS  causes  the  device  driver  to
        examine all output for the  above  characters,  and  to  adjust  $X
        and   $Y   accordingly.   By   default,   GT.M   performs   special
        maintenance  on  $X  and  $Y  only   for   MUMPS   format   control
        characters,     WRAPped     records,     and     certain     action
        deviceparameters.

   o    [NO]ESCAPE alters the effect of ANSI escape  sequences  on  $X  and
        $Y. ESCAPE causes GT.M to filter the  output,  searching  for  ANSI
        escape sequences and preventing them from updating $X  and  $Y.  By
        default, GT.M does not screen output for escape sequences.

   By  default,  GT.M   does   not   perform   output   filtering.   Output
   filtering adds additional overhead to I/O processing.

2 HOSTSYNC
  [NO]HOSTSYNC
   Enables or disables the host  from  using  XON/XOFF  to  throttle  input
   and  prevent  impending   buffer   overruns   for   a   terminal.   This
   deviceparameter   provides   important   control    for    inter-machine
   communication lines.

   By default, the device driver operates HOSTSYNC.

2 LENGTH
  LENGTH=intexpr
   Sets  the  virtual  page  length  for  an  I/O  device  to  the  integer
   expression. The page length controls  the  point  at  which  the  device
   driver automatically resets $Y to 0.

   By  default,  GT.M   uses   the   LENGTH   specified   by   the   device
   characteristics  at  image  activation.  The  terminal  default  depends
   on the type of terminal.

2 PASTHRU
  [NO]PASTHRU
   Enables  or  disables  interpretation  by  the   operating   system   of
   <CTRL>  characters  for  a  terminal.  When  a  terminal   has   PASTHRU
   enabled,  the  operating  system   passes   the   characters   that   it
   normally  uses  to  control  terminal   interaction   through   to   the
   application program.

   PASTHRU supersedes  line  EDITING.  Exercise  caution  with  PASTHRU  in
   debugging, as using a  PASTHRU  terminal  in  Direct  Mode  is  somewhat
   awkward.

   [NO]TTSYNC  must  be  used  with   [NO]PASTHRU   to   control   XON/XOFF
   handling.

   By default, the device driver operates NOPASTHRU.

2 REWIND
  REWIND
   REWIND  positions  magnetic  tapes  at  the  beginning  of  the  current
   file.

   REWIND  for  a  disk  file  is  a  logical  rather   than   a   physical
   operation.

   By default, USE does not REWIND.

2 TYPEAHEAD
  [NO]TYPEAHEAD
   Enables  or  disables  type-ahead  buffering  for   a   terminal.   With
   NOTYPEAHEAD  and  no  outstanding  READ,  the  terminal  device   driver
   discards  input  entered  at  the  terminal.  With  TYPEAHEAD   and   no
   outstanding  READ,  the  device  driver  stores  input  entered  at  the
   terminal in a type-ahead  buffer.  The  device  driver  uses  data  from
   the type-ahead buffer for subsequent READs.

   The size of the type-ahead buffer limits  the  amount  of  data  entered
   at the terminal that the device driver  can  store  in  anticipation  of
   future READs. When the type-ahead buffer  is  full,  the  device  driver
   sends a warning <BEL> character  to  the  terminal  and  discards  input
   that would overflow the buffer.

   By default, the terminal device driver accepts TYPEAHEAD.

2 UPSCROLL
  UPSCROLL
   Moves  the  cursor  down  one  line   on   the   terminal   screen.   If
   $Y=LENGTH-1, UPSCROLL sets $Y=0. Otherwise UPSCROLL increments $Y
   by one. If the cursor is physically at  the  bottom  of  the  page,  the
   screen scrolls  up  one  line.  UPSCROLL  does  not  change  the  column
   position or $X. UPSCROLL only works with $PRINCIPAL.

2 WIDTH
  WIDTH=intexpr
   Sets the device's logical record size and enables WRAP.

   NOWRAP and WIDTH supersede each other.  When  WIDTH  and  NOWRAP  appear
   together on the same USE command,  the  last  one  controls  the  device
   behavior.    For    a    terminal,    WIDTH=0    is    equivalent     to
   WIDTH=255:NOWRAP.  Terminals  inherit  their  default  WIDTH   in   GT.M
   from the invoking shell environment.

2 WRAP
  [NO]WRAP
   Enables or disables  automatic  record  termination.  When  the  current
   record size ($X) reaches the maximum  WIDTH  and  the  device  has  WRAP
   enabled, GT.M starts a new record,  as  if  the  routine  had  issued  a
   WRITE ! command.

   NOWRAP causes GT.M to  require  a  WRITE  !  to  terminate  the  record.
   NOWRAP  allows  $X  to  become  greater  than  the  device   WIDTH   for
   terminals.

   By default, WIDTH sets WRAP.  When  WIDTH  and  NOWRAP  appear  together
   on the same USE command, the last one controls the device behavior.

   By default, records WRAP.

2 X
  X=intexpr
   If  NOWRAP  or  intexpr<WIDTH,   the   terminal   device   driver   sets
   $X=intexpr. If WRAP is enabled and intexpr>WIDTH, GT.M sets
   $X=intexpr#WIDTH, where # is the MUMPS modulo operator. The
   resulting $X determines  the  actual  physical  position.  The  terminal
   hardware may affect physical cursor positioning.

   In order to ensure that $Y and  $X  match  what  is  visually  happening
   on  the   terminal,   the   GT.M   deviceparameters   and   the   device
   characteristics must match at all  times.  For  example,  if  a  process
   forks  out  of  GT.M  and  changes  the  terminal  wrap   setting   from
   NOWRAP, previously  set  with  the  GT.M  USE  command,  to  wrap,  GT.M
   does not  reflect  the  change  when  the  process  returns.  Therefore,
   wraps on the terminal do not reflect in the values of $X and $Y.

   The X deviceparameter does not change the cursor row or update $Y.

2 Y
  Y=intexpr
   Positions the cursor to a vertical row on the terminal.

   The terminal device  driver  sets  $Y=intexpr#LENGTH,  where  #  is  the
   MUMPS  modulo  operator.  If   intexpr<LENGTH,      the   resulting   $Y
   determines the physical  position.  If  intexpr>LENGTH,  the  cursor  is
   positioned so that  $Y=intexpr#LENGTH,  where  #  is  the  MUMPS  modulo
   operator.   The   terminal   hardware   may   affect   physical   cursor
   positioning.

   In order to ensure that $Y and  $X  match  what  is  visually  happening
   on  the   terminal,   the   GT.M   deviceparameters   and   the   device
   characteristics must match at all  times.  For  example,  if  a  process
   forks  out  of  GT.M  and  changes  the  terminal  wrap   setting   from
   NOWRAP, previously  set  with  the  GT.M  USE  command,  to  wrap,  GT.M
   does not  reflect  the  change  when  the  process  returns.  Therefore,
   wraps on the terminal do not reflect in the values of $X and $Y.

   The Y deviceparameter does  not  change  the  cursor  column  or  update
   $X.

1 VIEW
  View Command
   The VIEW command adjusts an environmental factor  selected  by  a  keyword
   argument.  For   example,   VIEW   controls   journal   buffer   flushing,
   determines  whether  GT.M  reports  undefined  variables  as   errors   or
   treats  them  as  null,  and  determines  which  BREAK   commands   should
   display messages.

   The format of the VIEW command is:

   V[IEW][:tvexpr] keyword[:expr2[:...]][,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The keyword specifies the environmental factor to change

   o    The optional expression following the keyword  specifies  the  nature
        of the change to the environmental factor

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more VIEW arguments form a legal argument for a VIEW

   The following sections  describe  the  keywords  available  for  the  VIEW
   command in GT.M.

2 BREAKMSG
  "BREAKMSG":value
   Sets the value  of  the  BREAK  message  mask.  When  GT.M  processes  a
   BREAK command, the BREAK message mask  controls  whether  to  display  a
   message describing the source of the BREAK.

   The mask has four values as  follow,  which  when  added  together  give
   the BREAKMSG value.

      1 - BREAKs within the body of a program

      2 - BREAKs within a ZBREAK action

      4 - BREAKs within a device EXCEPTION

      8 - BREAKs within a ZSTEP action

   By     default     GT.M      displays      all      BREAK      messages.
3 Example
  VIEW "BREAKMSG" Example

   Example

   GTM> VIEW "BREAKMSG":5

   In this example the BREAKMSG value is  5,  i.e.,  the  sum  of  1  and
   4. This enables  BREAKS  within  the  body  of  a  program  (value  1)
   and for a device EXCEPTION (value 4).

2 GDSCERT
  "GDSCERT":value
   Enables    (value=1)    or    disables    (value=0)    database    block
   certification.

   Database  block  certification  causes  GT.M  to  check   the   internal
   integrity   of   every   block   as   it   writes   the   block.   Block
   certification  impacts  performance  and  exists  primarily  as  a  tool
   for use by Greystone.

2 JNLFLUSH
  "JNLFLUSH"[:region]
   Writes  or  flushes  journaling  buffers  associated  with   the   given
   region to permanent storage e.g., disk.  If  the  VIEW  "JNLFLUSH"  does
   not specify the optional region, GT.M  flushes  all  active  regions  of
   the current Global Directory.

   Normally  GT.M  writes  journal  buffers  when  it  fills  the   journal
   buffer pool  or  when  some  period  of  time  passes  with  no  journal
   activity.

   For  more  information  on  journaling,  refer   to   the   "Journaling"
   chapter in the GT.M Administration and Operations Guide.

2 LABELS
  "LABELS":"value"
   Enables    (value="LOWER")    or    disables    (value="UPPER")     case
   sensitivity for labels within routines.

   It is important to have the  same  case  handling  at  compile-time  and
   run-time.

2 LVNULLSUBS
  "[NO]LVNULLSUBS"
   Allows or disallows local arrays to have null subscripts.

   By  default,  GT.M  allows  local  arrays  to  have   null   subscripts.
   LINKing  a  GT.M  image  with  a  modified   GTM$DEFAULTS   alters   the
   default for  that  image.  For  more  information  on  GTM$DEFAULTS  see
   the "Program Development" chapter in the GT.M Programmer's Guide.

2 UNDEF
  "[NO]UNDEF"
   Enables  or  disables  handling  undefined  variables  as  errors.  With
   UNDEF,  GT.M  handles  all  references  to  undefined  local  or  global
   variables as errors.  With  NOUNDEF,  GT.M  handles  all  references  to
   undefined local or global variables as  if  the  variable  had  a  value
   of  the  null  string.  In  other  words,  GT.M  treats  all   variables
   appearing  in  expressions  as  if  they  were  the   argument   of   an
   implicit $GET().

   By   default   GT.M    treats    undefined    variables    as    errors.
2 Examples
  VIEW Examples

   Example
   
   GTM> KILL A
   GTM> VIEW "NOUNDEF"
   GTM> WRITE A,?10,$L(A)
   0
   GTM>

   This  demonstrates  how  a  VIEW   that   specifies   NOUNDEF   prevents
   UNDEFined errors.

   Example:

   GTM> ZP ^NOSENSE
   NOSENSE;
      DO lab
      QUIT
   LAB      WRITE !,"THIS IS NOSENSE"
      QUIT

   GTM> VIEW "LABELS":"UPPER"
   GTM> ZLINK "NOSENSE.m"
   GTM> DO ^NOSENSE

   THIS IS NOSENSE

   GTM>

   This demonstrates use of VIEW  "LABELS"  to  make  label  handling  case
   insensitive. Notice that the  routine  was  ZLINKed  with  an  extension
   of .m to force a recompile and ensure  that  the  object  code  and  the
   run-time handling of labels is the same.

1 WRITE
  W[RITE]
   The  WRITE  command  transfers  a  character  stream  specified   by   its
   arguments to the current device.

   The format of the WRITE command is:

   W[RITE][:tvexpr] expr|*intexpr|fcc[,...]

   o   The  optional  truth-valued  expression  immediately   following   the
       command is a  command  postconditional  which  controls  whether  GT.M
       executes the command or not

   o   An expression argument supplies the text of a WRITE

   o   When a WRITE argument consists of  a  leading  asterisk  (*)  followed
       by  an  integer  expression,  WRITE  outputs   one   ASCII   character
       specified by the integer evaluation of the expression

   o   WRITE also accepts format  control  characters  as  arguments;  format
       control characters  modify  the  position  of  a  virtual  cursor:  an
       exclamation  point  (!)  produces  a  new  line,  a  number-sign   (#)
       produces  a  new  page  and  a  question-mark  (?)  followed   by   an
       expression moves the virtual cursor to the  column  specified  by  the
       integer evaluation of the expression  if  the  virtual  cursor  is  to
       the "left" of the specified column

   o   An indirection operator and an expression atom evaluating  to  a  list
       of one or more WRITE arguments form a legal argument for a WRITE

   GT.M can write up to  32,767  bytes  (the  GT.M  maximum  string  length).
   GT.M buffers output  into  a  "logical  record"  for  all  devices  except
   streams. The WRITE command appends a  string  to  the  current  record  of
   the current device. GT.M does not write to the  output  device  until  the
   buffer is full, a MUMPS format  control  character  forces  a  write,  or,
   for terminals, the buffer becomes stale.

   Each  device  has  a  WIDTH  and  a  LENGTH,  which  together  define  the
   virtual "page". The WIDTH determines the maximum  size  of  a  record  for
   a device, while the LENGTH determines how many  records  fit  on  a  page.
   When the current record size  ($X)  reaches  the  maximum  WIDTH  and  the
   device has WRAP enabled, GT.M  starts  a  new  record.  When  the  current
   line ($Y) reaches the maximum LENGTH, GT.M starts a new page.

2 Format_control
  Write Format Control Characters
   The WRITE command has several  format  control  characters  which  allow
   the manipulation of  the  virtual  cursor.  For  all  I/O  devices,  the
   MUMPS format control characters do the following:

   WRITE *          Writes the character corresponding to the decimal ASCII
                    representation supplied.

   WRITE !          Clears $X and increments $Y and terminates the logical
                    record in progress. The definition of "logical record"
                    varies from device to device, and is discussed in each
                    device section.

   WRITE #          Clears $X and $Y and terminates the logical record in
                    progress.

   WRITE ?n         If n is greater than $X,  writes  n-$X  spaces  to  the
                    device, bringing $X to n. If n is less than or equal to
                    $X, WRITE ?n has no effect. When WRAP is enabled and n
                    exceeds the LENGTH of the line, WRITE ?n increments $Y.

1 XECUTE
  Xecute Command
   The XECUTE  command  makes  an  entry  in  the  MUMPS  virtual  stack  and
   executes the argument as MUMPS code.

   The format of the XECUTE command is:

   X[ECUTE]:tvexpr expr[:tvexpr][,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The required expression specifies a fragment of MUMPS source code

   o    The  optional  truth-valued  expression  immediately  following   the
        argument  expression  specifies  the  argument  postconditional   and
        controls whether GT.M performs an XECUTE with that argument

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more XECUTE arguments form a legal argument for an XECUTE

   An explicit or implicit QUIT within the  scope  of  the  XECUTE,  but  not
   within the scope of any  other  DO,  FOR,  XECUTE  or  extrinsic,  returns
   execution to the instruction following the  calling  point.  This  may  be
   the next XECUTE argument or  a  new  command.  At  the  end  of  the  code
   specified  by  the  XECUTE  argument   expression,   MUMPS   performs   an
   implicit QUIT.

   Because  XECUTE  causes  run-time  compilation  in  GT.M  and  because  it
   tends to obscure code, use  XECUTE  only  when  other  approaches  clearly
   do not meet your particular requirement.

2 Examples
  XECUTE Examples

   Example

   GTM> SET A="HELLO" XECUTE "WRITE A"
   HELLO

   GTM>

   This demonstrates a simple (and unnecessary) use of XECUTE.

   Example

          S x="" F  S x=$O(^%x(x)) Q:x=""  X x

   This  $ORDER()  loop  XECUTEs  code  out  of  the  first  level  of  the
   global array ^%x. Note that,  in  most  cases,  having  the  code  in  a
   GT.M  source  file,  say  TMPX.m,  and  using  a   DO   ^TMPX   improves
   efficiency.

1 ZALLOCATE
  ZAllocate
   The  ZALLOCATE  command  locks  the  specified  name   without   releasing
   previously reserved  names.  Other  MUMPS  processes  cannot  reserve  the
   ZALLOCATEd name with a ZALLOCATE or LOCK command.

   The  ZALLOCATE  command  provides  compatibility  with  some  other  MUMPS
   implementations. The MUMPS Development  Committee  choose  to  add  the  +
   and - delimiters to the LOCK command  (incremental  locking)  rather  than
   adopt the ZALLOCATE and ZDEALLOCATE approach.  Therefore,  when  a  design
   requires an  incremental  lock  mechanism,  LOCK  +/-  has  the  advantage
   over ZALLOCATE/ZDEALLOCATE of being part of the MUMPS standard.

   For  more  information  on  troubleshooting  locks  with  the  MUMPS  Lock
   Utility  (LKE),  refer  to   the   appropriate   chapter   of   the   GT.M
   Administration and Operations Guide.

   The format of the ZALLOCATE command is:

   ZA[LLOCATE][:tvexpr] [(]nref[,...[)]][:intexpr][,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The nref argument specifies a name in the format  of  a  MUMPS  local
        or global variable name with or without subscripts

   o    Only one  process  in  an  environment  can  ZALLOCATE  (or  LOCK)  a
        particular resource name at any given time

   o    Because the data storage in MUMPS  uses  hierarchical  sparse  arrays
        and ZALLOCATE may serve  to  protect  that  data  from  inappropriate
        "simultaneous"  access  by  multiple  processes,   ZALLOCATE   treats
        resource names in a hierarchical fashion; a  ZALLOCATE  protects  not
        only the named resource, but also its ancestors and descendants

   o    When one or more nrefs are  enclosed  in  parentheses  (),  ZALLOCATE
        reserves all the enclosed names "simultaneously," i.e.,  it  reserves
        none of them until all become available

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more ZALLOCATE  arguments  form  a  legal  argument  for  a
        ZALLOCATE

   For an explanation of the interaction between  LOCKs  and  ZALLOCATEs  and
   databases and global names see the "LOCK" command in this chapter.

2 Examples
  ZALLOCATE Examples

   Examples:

   ZA A
   ZA ^A
   ZA ^A(1)
   ZA (^B("smith"),^C("jones"))
   ZA @A

   The first command  ZALLOCATEs  A;  the  second,  ^A;  the  third,  ^A(1)
   and the fourth, ^B("smith")  and  ^C("jones")  at  the  same  "instant."
   The last command ZALLOCATEs the resources named  by  the  value  of  the
   variable A.

   The  ZALLOCATE  command  takes  more  than  one  argument  separated  by
   commas.

   Example

   ZA  A,^B,@C
   ZA (A,B,C)

   If  ZALLOCATE  arguments  are  enclosed  in  parentheses,  the   command
   reserves the specified names  at  the  same  time.  That  is,  ZALLOCATE
   waits until all names in  the  argument  list  become  available  before
   reserving  any  of  the  names.  For  example,  in  the   statement   ZA
   (A,B,C), if the resource named  C  is  not  available,  ZALLOCATE  waits
   until C becomes available before reserving A and B.

   When a process attempts to ZALLOCATE  a  name  currently  ZALLOCATEd  or
   LOCKed (with the LOCK command)  by  another  process,  the  ZALLOCATEing
   process hangs  until  the  other  process  releases  the  name.  In  the
   event  that  names  remain  unavailable  for  significant   periods   of
   time,  timeouts  allow  the  process  issuing  a  ZALLOCATE  to   regain
   program control.

   Example

   ZA ^D:5

   This example specifies  a  timeout  of  five  seconds.  If  a  ZALLOCATE
   command specifies a timeout  and  GT.M  reserves  the  argument  name(s)
   before  the  timeout  elapses,  ZALLOCATE  sets  $TEST  to  true.  If  a
   ZALLOCATE command specifies  a  timeout  and  GT.M  cannot  reserve  the
   argument name(s) within the timeout,  ZALLOCATE  sets  $TEST  to  false.
   If a ZALLOCATE command does not specify  a  timeout,  the  execution  of
   the command does not affect $TEST.

   When  you  ZALLOCATE  a  new  name,  the  ZALLOCATE  command  does   not
   release  names  previously  reserved  with   ZALLOCATE   or   the   LOCK
   command  (similarly,  LOCK  does  not  release  names  that  have   been
   ZALLOCATEd).  For  example,  after  ZALLOCATEing  A   and   LOCKing   B,
   LOCKing B does not release A, and ZALLOCATEing  C  does  not  release  A
   or B.

   To  release  a  ZALLOCATEd  name,  use  the  ZDEALLOCATE  command.   The
   ZDEALLOCATE command can only release previously ZALLOCATEd names.

   Resource  name  arguments  for  LOCKs  and  ZALLOCATEs  intersect.  That
   is, if one process holds  a  LOCK  or  ZALLOCATE,  another  process  can
   neither LOCK nor ZALLOCATE any name falling  in  the  hierarchy  of  the
   resource name held  by  the  first  process.  When  a  process  holds  a
   LOCK or  ZALLOCATE,  that  same  process  may  also  LOCK  or  ZALLOCATE
   resource  names  falling  in  the  hierarchy  of  the   currently   held
   resource  name.  When  a   single   process   holds   both   LOCKs   and
   ZALLOCATEs, a LOCK does  not  release  the  ZALLOCATEd  resource(s)  and
   a ZDEALLOCATE does not release the LOCKed resource(s).

   Example

          L ^AR(PNT)
          .
          .
          .
          ZALLOCATE ^AR(PNT,SUB)
          .
          .
          .
          L ^TOT(TDT)
          .
          .
          .
          ZDEALLOCATE ^AR(PNT,SUB)

   This  LOCKs  ^AR(PNT),   then,   after   performing   some   unspecified
   commands,  it  ZALLOCATEs  ^AR(PNT,SUB).  Because  ZALLOCATE  does   not
   imply any  change  to  LOCKs  or  existing  ZALLOCATEd  resource  names,
   the LOCK of ^AR(PNT)  remains  in  effect.  Assuming  the  routine  does
   not modify the  variable  PNT,  ^AR(PNT,SUB)  is  already  protected  by
   the  LOCK.  Next,  because  an  unsigned  LOCK  releases  all   resource
   names  currently  LOCKed  by   the   process,   the   routine   releases
   ^AR(PNT) with the LOCK  of  ^TOT(TDT).  This  leaves  the  ZALLOCATE  of
   ^AR(PNT,SUB). The name ^AR and  all  its  subscripts  except  for  those
   that begin with ^AR(PNT,SUB) are now  available  for  LOCKing  by  other
   processes.  Finally   the   routine   releases   ^AR(PNT,SUB)   with   a
   ZDEALLOCATE command.  The  ZDEALLOCATE  does  not  affect  the  LOCK  on
   ^TOT(TDT). Note that this example  was  constructed  to  illustrate  the
   interaction  between  LOCK,  ZALLOCATE  and  ZDEALLOCATE,  and  not   to
   illustrate sound programming practice.

   Because  the  ZALLOCATE  command  reserves   names   without   releasing
   previously  reserved  names,  it  can  lead  to  deadlocks.    To  avoid
   deadlocks,  use  a  timeout.  Because  unsigned  LOCKs  always   release
   previously reserved names, such LOCKs inherently prevent deadlocks.

1 ZBREAK
  ZBreak
   The  ZBREAK  command   sets   or   clears   routine   breakpoints   during
   debugging.

   The format of the ZBREAK command is:

   ZB[REAK][:tvexpr] [-]entryref[:expr[:intexpr]][,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The required entryref  specifies  a  location  within  a  routine  at
        which to  set or remove a breakpoint

   o    The optional minus sign [-] specifies ZBREAK remove  the  breakpoint;
        -* means remove all breakpoints

   o    The optional  expression  specifies  a  fragment  of  MUMPS  code  to
        XECUTE  when  MUMPS  execution  encounters  the  breakpoint;  if  the
        ZBREAK argument does not specify an action,  the  default  action  is
        "BREAK"

   o    The   optional   integer   expression   immediately   following   the
        expression  specifies  a  count  of  process  transits  through   the
        breakpoint before the  breakpoint  action  takes  effect;  once  GT.M
        exhausts the count and the action takes  effect,  the  action  occurs
        every time the process encounters the breakpoint

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more ZBREAK arguments form a legal argument for a ZBREAK

   When  GT.M  encounters  the  entryref,  GT.M  suspends  execution  of  the
   routine code and XECUTEs the breakpoint action  before  executing  any  of
   the commands on the line. For more  information  on  entryrefs,  refer  to
   the "General Features" chapter in the GT.M Programmer's Guide.

   A count of integer expression activates the  breakpoint  on  the  intexpr-
   th  time  the   process   encounters   the   breakpoint   during   routine
   execution. Once GT.M activates the  breakpoint,  that  breakpoint  remains
   active until explicitly removed or until the image terminates.

   For more information, refer to the  "Direct  Mode"  chapter  in  the  GT.M
   Programmer's Guide.

2 Examples
  ZBREAK Examples

   Example

   GTM> ZP ^ZBTEST
   ZBTEST;
          DO SUB
          QUIT
   SUB    W !,"This is ZBTEST"
          QUIT

   GTM> ZBREAK SUB^ZBTEST
   GTM> DO ^ZBTEST
   %GTM-I-BREAKZBA,    Break    encountered    during     ZBREAK     action
                    At MUMPS source location SUB^ZBTEST
   GTM> ZSHOW "B"
   SUB^ZBTEST:"B"

   This inserts a  ZBREAK  with  a  default  action  at  SUB^ZBTEST.  After
   MUMPS encounters the BREAK, the ZSHOW "B"  displays  this  as  the  only
   ZBREAK in the image.

   Example

   GTM> ZBREAK -*
   GTM> ZGOTO 1
   GTM> ZBREAK "W !,""Trace"""
   GTM> DO ^ZBTEST

   Trace
   This is ZBTEST

   GTM>

   This removes all existing ZBREAKs with a ZBREAK  -*.  Note  that  it  is
   not  necessary  to  remove  ZBREAKs  before  modifying  them.  It   also
   clears the process  virtual  stack  with  an  argumentless  ZGOTO.  Then
   it uses a ZBREAK to insert a  trace-point.  Every  time  MUMPS  executes
   the line to where ZBREAK has  established  a  trace-point,  it  performs
   the specified action without entering Direct Mode.

1 ZCOMPILE
  ZCOMpile
   The ZCOMPILE command invokes the  GT.M  compiler  from  within  the  MUMPS
   run-time  environment.  Within  MUMPS  itself,   ZCOMPILE   provides   the
   functionality of the MUMPS command, except for mumps -direct.

   The format of the ZCOMPILE command is:

   ZCOM[PILE][:tvexpr] expr[,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The expression argument specifies one or  more  filenames  (in  which
        wild-cards are acceptable) and, optionally, qualifiers  valid  for  a
        MUMPS command.

   The $ZCSTATUS intrinsic special variable holds the  value  of  the  status
   code for the compile performed by a ZCOMPILE command.

   For a  description  of  MUMPS  arguments  and  qualifiers,  refer  to  the
   "Program Development" chapter in the GT.M Programmer's Guide.

1 ZCONTINUE
  ZContinue
   The  ZCONTINUE  command  continues  routine  execution   after   a   BREAK
   command or a <CTRL C>.

   The format of the ZCONTINUE command is:

   ZC[ONTINUE][:tvexpr]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    Because the ZCONTINUE has no argument, at least two (2)  spaces  must
        follow the command to separate it from the next command on  the  line
   

   o    If the process is not in Direct Mode, ZCONTINUE has no effect

1 ZDEALLOCATE
  ZDeallocate
   The ZDEALLOCATE command releases a  specified  name  or  names  previously
   reserved by the ZALLOCATE command.     The  ZDEALLOCATE  command  releases
   only the  specified  name(s)  without  releasing  other  names  previously
   reserved with the ZALLOCATE or LOCK command.

   The ZDEALLOCATE command  provides  compatability  with  some  other  MUMPS
   implementations. The MUMPS Development  Committee  choose  to  add  the  +
   and - delimiters  to the LOCK command  rather  than  adopt  the  ZALLOCATE
   and  ZDEALLOCATE  approach.  Therefore,  when   a   design   requires   an
   incremental lock mechanism, LOCK +/-  has  the  advantage  of  being  part
   of the MUMPS Language Standard.

   The format of the ZDEALLOCATE command is:

   ZD[EALLOCATE][:tvexpr] [nref[,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The nref argument specifies a name in the format  of  a  MUMPS  local
        or global variable name with or without subscripts

   o    A  ZDEALLOCATE  with  no  argument  releases  all   names   currently
        reserved with ZALLOCATE by the process; in this case,  at  least  two
        (2) spaces must follow the ZDEALLOCATE to separate it from  the  next
        command on the line

   o    ZDEALLOCATEing a named resource that is not currently  owned  by  the
        process has no effect

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more ZDEALLOCATE arguments form  a  legal  argument  for  a
        ZDEALLOCATE

   For an example of the  use  of  the  ZDEALLOCATE  command,  refer  to  the
   section on ZALLOCATE.

1 ZEDIT
  ZEDit
   The  ZEDIT  command  invokes  the   editor   specified   by   the   EDITOR
   environment  variable  for  GT.M  and  opens  the   specified   file   for
   editing. If the EDITOR environment  variable  is  undefined,  ZEDIT  tries
   to invoke usr/bin/vi by default.

   The format of the ZEDIT command is:

   ZED[IT][:tvexpr] [expr[,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional expression specifies the name of a file  to  edit;  note
        the argument is  an  expression  rather  than  a  routinename;  ZEDIT
        rejects arguments of file extension .o  as  illegal.  A  valid  MUMPS
        filename with no extension will automatically be given  an  extension
        of .m; therefore it is not possible, through ZEDIT, to  edit  a  file
        with a valid MUMPS filename and no extension.

   o    If ZEDIT has an argument, it not only invokes the  editor,  but  also
        sets zsource=expr.

   o    If ZEDIT has no argument or expr="", the  command  acts  as  a  ZEDIT
        zsource; at least two (2) spaces must follow  a  ZEDIT  command  with
        no argument to separate it from the next command on the line

   o    GT.M stores source code  in  files  with  standard  operating  system
        format;  generally  the  file  name  is  the  same   as   the   MUMPS
        routinename with a default extension of .m

   If  the  filename  includes  a  directory,  ZEDIT   searches   only   that
   directory. If zroutines is  not  null,  a  ZEDIT  command  that  does  not
   specify a directory uses  zroutines  to  locate  files.  If  zroutines  is
   null,  ZEDIT  uses  the  current  directory.  For  more   information   on
   zroutines, refer to the appropriate  section  in  the  "Intrinsic  Special
   Variables" chapter of the GT.M Programmer's Guide.

   When the argument to a ZEDIT includes a  file  name,    zsource  maintains
   that file name as a default for  ZEDIT  and  ZLINK.  A  ZEDIT  without  an
   argument  is  equivalent  to  ZEDIT  zsource.  For  more  information   on
   zsource,  refer to the  appropriate  section  in  the  "Intrinsic  Special
   Variables" chapter of  the GT.M Programmer's Guide.

2 Examples
  ZEDIT Examples

   Example

   GTM> ZEDIT "BAL"

   This invokes  the  editor  for  a  file  with  a  name  of  BAL  and  an
   extension of .m. Notice that BAL is a string literal.

   Example

   GTM> S prog="BAL"
   GTM> ZEDIT prog

   This is similar to the first example except  that  it  uses  a  variable
   argument rather than a string literal.

   Example

   GTM> ZEDIT "LOGIN.COM"

   This invokes the editor  for  a  file  with  a  name  of  LOGIN  and  an
   extension of .COM. Notice that in this case the  file  is  not  a  MUMPS
   file.

1 ZGOTO
  ZGoto
   The ZGOTO command  transfers  command  to  various  levels  in  the  MUMPS
   execution stack. It also  can  transfer  control  from  one  part  of  the
   routine to another or from one routine  to  another  using  the  specified
   entryref.

   The format of the ZGOTO command is:

   ZG[OTO][:tvexpr] [intexpr:[entryref[:tvexpr]]...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional integer expression specifies  the  stack  frame  nesting
        level reached by performing the ZGOTO

   o    A ZGOTO with no argument returns control to the next command  at  the
        bottom of the stack (level  1);  in  this  case,  at  least  two  (2)
        spaces must follow the command to separate it from the  next  command
        on the line

   o    The optional entryref specifies a location to which  ZGOTO  transfers
        control

   o    If ZGOTO specifies no  entryref,  it  returns  control  to  the  next
        command at level integer expression

   o    The  optional  truth-valued  expression  immediately  following   the
        entryref  specifies  the  argument   postconditional   and   controls
        whether GT.M uses the argument

   o    If the ZGOTO includes the  level  and  the  argument  postconditional
        but  not  the  entryref,  two  colons  (::)  separate   the   integer
        expression from the truth-valued expression

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more ZGOTO arguments form a legal argument for a ZGOTO

   A ZGOTO command with an  entryref  performs  a  similar  function  to  the
   GOTO command,  with  the  additional  capability  of  reducing  the  MUMPS
   stack level. In a single operation, ZGOTO  executes  ($ZLEVEL  -  intexpr)
   implicit QUITs and a GOTO operation  transferring  control  to  the  named
   entryref. For  more  information  on  entryrefs,  refer  to  the  "General
   Features" chapter in the GT.M Programmer's Guide.

   The ZGOTO command  leaves  the  invocation  stack  at  the  level  of  the
   value   of   integer   expression.   GT.M   implicitly   terminates    any
   intervening FOR loops and unstacks variables  stacked  with  NEW  commands
   as appropriate.

   ZGOTO 0 causes  an  exit  from  the  current  MUMPS  invocation.  ZGOTO  0
   resembles HALT (and not QUIT) in that it  causes  an  exit  regardless  of
   the  number  of  active  levels  in  the  current  invocation.   ZGOTO   0
   resembles QUIT (and not HALT)  in  that  it  destroys  the  MUMPS  context
   and terminates the image only  if  the  current  MUMPS  invocation  is  at
   the base of the image. Therefore,  the  difference  between  ZGOTO  0  and
   HALT matters only in an environment where  MUMPS  is  invoked  recursively
   from other languages.

   ZGOTO $ZLEVEL:LABEL^ROUTINE takes the same  action  as  GO  LABEL^ROUTINE.
   ZGOTO $ZLEVEL-1 has the same  results  as  QUIT  (followed  by  ZCONTINUE,
   if in Direct Mode).

   If  the  integer  expression  evaluates  to  a  value  greater  than   the
   current value of $ZLEVEL or less than zero (0),  GT.M  issues  a  run-time
   error.

   If ZGOTO has no entryref,  it  performs  some  number  of  implicit  QUITs
   and transfers control to the next  command  at  the  specified  level.  If
   ZGOTO has no argument, it acts as ZGOTO  1,  which  resumes  operation  of
   the lowest level MUMPS routine as displayed by ZSHOW  "S".  In  the  image
   invoked  by  $gtm_dist/mumps,  a  ZGOTO  without  arguments  returns   the
   process to Direct Mode.

   ZGOTO  provides  a  useful  debugging  tool  in  Direct   Mode.   However,
   because ZGOTO is not conducive to  structured  coding,  use  of  ZGOTO  in
   production programs should generally  be  restricted  to  error  handling.
   For  more  information  on  error  handling,  refer  to  the   "Processing
   Errors"  chapter of the GT.M Programmer's Guide.

2 Examples
  ZGOTO Examples

   Example

   GTM> ZGOTO
   %GTM-I-BREAK, Break instruction encountered
                  At MUMPS source location +1^GTM$DMOD
   GTM>ZSHOW
   +1^GTM$DMOD  (Direct mode)
   GTM>

   This uses ZGOTO  to  clear  all  levels  of  the  MUMPS  virtual  stack.
   ZSHOW with no arguments displays the stack.

   Example

          SET $ZTRAP="ZGOTO "_$ZLEVEL_":^ERROR"

   This SETs $ZTRAP to contain a ZGOTO, such that  if  and  when  an  error
   causes GT.M  to  XECUTE  $ZTRAP,  the  routine  ERROR  executes  at  the
   same level as the SET command shown in the example.

1 ZHELP
  ZHelp
   The ZHELP command  provides  access  to  help  information  from  the  GTM
   help  library  or  from  any  help  library  specified  in   the   command
   argument.

   The format of the ZHELP command is:

   ZH[ELP][:tvexpr] [expr1[:expr2]...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional first expression specifies the help topic

   o    If ZHELP has no  argument  or  expr1="",  ZHELP  invokes  base  level
        help; at least two (2) spaces must follow a  ZHELP  command  with  no
        argument to separate it from the next command on the line

   o    The optional  second  expression  specifies  the  name  of  a  Global
        Directory containing ^HELP.

   o    If ZHELP does not specify the second  expression,  the  name  of  the
        Global Directory defaults to $gtm_dist/gtmhelp.glb.

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more ZHELP arguments form a legal argument for a ZHELP

1 ZLINK
  ZLink
   If the current image does not contain a  copy  of  a  routine,  the  ZLINK
   command adds an executable MUMPS routine to  the  current  image.  If  the
   current image contains a copy of a routine,  the  ZLINK  command  replaces
   the current  routine  image  with  a  "new"  version.  If  necessary,  the
   ZLINK command compiles the  routine  prior  to  integrating  it  with  the
   image.

   Under certain circumstances, GT.M can  automatically  ZLINK  the  routines
   for which the execution calls. If executing code that  was  added  to  the
   image by GT.M makes a  reference  to  an  unknown  routine,  the  run-time
   system attempts to auto-ZLINK the  missing  routine.  Code  added  to  the
   image  by  GT.M  includes  previously  ZLINKed   routines,   XECUTEs   and
   instances of indirection. A  subsequent  section  discusses  auto-ZLINKing
   in more detail.

   The format of the ZLINK command is:

   ZL[INK][:tvexpr] [expr[,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional  expression specifies the full or partial file  name  of
        a routine to ZLINK; if ZLINK has an argument, it not  only  adds  the
        routine to the image, but also sets zsource=expr

   o    If ZLINK has no argument,  or  expr="",  it  uses    zsource  as  the
        routine filename; at  least  two  (2)  spaces  must  follow  a  ZLINK
        command with no argument to separate it  from  the  next  command  on
        the line

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more ZLINK arguments form a legal argument for a ZLINK

   ZLINK cannot change a routine that  MUMPS  is  currently  in  the  process
   of executing. Changing a routine  in  progress  would  have  unpredictable
   results. An attempt to ZLINK an  active  routine  results  in  a  run-time
   error. To ZLINK  the  routine,  first  remove  it  from  the  MUMPS  stack
   using ZGOTO, or the appropriate number of QUITs.  Use  the  ZSHOW  command
   to see the currently active routines.

   When the ZLINK command  specifies  a  file,  GT.M  sets  zsource  to  that
   file name. By default, ZLINK  and  ZEDIT  use  zsource  for  a  file  name
   when they have a missing or null  argument.  A  subsequent  ZLINK  without
   an argument is equivalent  to  ZLINK  zsource.  For  more  information  on
   zsource, refer to  the  appropriate  section  in  the  "Intrinsic  Special
   Variables" chapter in the GT.M Programmer's Guide.

   NOTE: In order to ensure compatibility with  GT.M  versions  that  do  not
   permit the percent sign in a file name, use an  underscore  (_)  in  place
   of the percent in the  ZLINK  file-specification  for  routines  beginning
   with a percent (%) sign.

   If  the  file-specification  includes  an  explicit  directory,      ZLINK
   searches only that directory. Otherwise, if  $ZROUTINES  is  not  null,  a
   ZLINK command that  does  not  specify  a  directory  uses  $ZROUTINES  to
   locate files. If $ZROUTINES is null, ZLINK  uses  the  current  directory.
   For more information on  $ZROUTINES,  refer  to  the  appropriate  section
   in the "Intrinsic Special Variables" chapter in    the  GT.M  Programmer's
   Guide.

   If the filename contains  an  explicit  file  extension,  ZLINK  processes
   the file according to the extension.  ZLINK  file  extensions  can  either
   be object {(.OBJ)\(.o)} or source (usually .m).  If  the  file  name  does
   not specify a file extension,  ZLINK  attempts  to  find  and  match  both
   the object and source for a routine.

2 Compilation
  ZLINK Compilation
   If  ZLINK  compiles  the  routine  ZLINK  places  the  resulting  object
   file in  the  directory  where  it  would  be  found  according  to  the
   search criteria.  ZLINK  incorporates  the  new  object  file  into  the
   image, regardless of where it placed the file.

2 Examples
  ZLINK Examples

   Example

   GTM> ZLINK "test"

   If  ZLINK  finds  test.m  or  {test.obj\test.o},  it  adds  the  routine
   "test" to the  current  image.  If  ZLINK  finds  no  {test.obj\test.o},
   or finds that {test.obj\text.o} is  older  than  test.m,  GT.M  compiles
   test.m to produce a new {test.obj\test.o},  and  adds  the  contents  of
   the new object file to the image.

   Example

   GTM> ZLINK "test.m":"/noobject/list"

   This  compiles  the  routine  "test"  and  produces  a  listing  but  no
   object file. Because the  example  produces  no  object  file,  it  does
   not change the current image.

2 Auto-ZLINK
  Auto-ZLINK
   If a MUMPS routine references a  routine  that  is  not  linked  to  the
   MUMPS image, GT.M automatically  attempts  to  ZLINK  that  routine.  An
   auto-ZLINK  is  functionally  equivalent  to  an  explicit  ZLINK  of  a
   routine without a specified directory or file  extension.

3 Commands
  Commands That Can Cause Auto-ZLINK

   The  MUMPS  commands  and  functions  that  may  cause   auto-ZLINKing
   are:

   o    DO

   o    GOTO

   o    ZBREAK

   o    ZGOTO

   o    ZPRINT

   o    $TEXT()

3 Conditions
  Auto-ZLINK Preconditions

   GT.M  auto-ZLINKs  the  routine  only  if  the  following   conditions
   are met:

   o    ZLINK can locate and  process  the  routine  file,  as  indicated
        in the previous ZLINK Operation Summary table

   o    The name of the routine is the same as the  name  of  the  source
        file; the only exception  is  in  cases  where  GT.M  converts  a
        leading percent sign (%) in a file name to an underscore (_)

1 ZLINKing
  ZLINKing
   As discussed in  the  section  on  compiling  source  programs,  the  GT.M
   command  ZLINK  compiles  the  source  code  into  an  object  module  and
   then adds the object module to the current image.

   The run-time  system  provides  auto-ZLINKing  whenever  a  MUMPS  command
   references a routine  that  is  not  part  of  the  current  image.  If  a
   program or a Direct  Mode  command  references  a  routine  that  was  not
   referenced  in  the  LINK  of  the  image  and  has  not  been  previously
   used, i.e., is  not  part  of  the  current  image,  the  run-time  system
   provides auto-ZLINKing.

   The MUMPS commands and functions that may cause auto-ZLINKing are:

   o    DO

   o    GOTO

   o    ZBREAK

   o    ZGOTO

   o    ZPRINT

   o    $TEXT()

   GT.M auto-ZLINKs the routine only if three conditions are present:

   o    ZLINK  can  locate  the  routine  file  using   $zroutines   or   the
        current directory if $zroutines is null

   o    The name of the routine is  the  same  as  the  name  of  the  source
        file

   ZLINK and auto-ZLINK require the name  of  the  routine  to  be  the  same
   as the name of the source file.

   When the argument  to  a  ZLINK  command  includes  a  file-specification,
   $zsource maintains that file-specification as a default for ZEDIT
   and ZLINK.

   $zsource is a read-write special variable that maintains this
   default  file-specification.  $zsource   initially   contains   the   null
   string.

   Once  you  use  the  ZEDIT  or  ZLINK  commands,   $zsource   contains   a
   partial  file  specification.  The  partial  file  specification  consists
   of  a directory path  and  a  file  name.  It  may  also  contain  a  file
   extension. You can set $zsource with a MUMPS SET command.

   A  ZLINK  without  an  argument  is  equivalent  to  ZLINK  $zsource.  For
   more  information  on  $zsource,   refer   to   the   "Intrinsic   Special
   Variables" chapter of the GT.M Programmer's Guide.

   Example

   GTM>ZLINK "TAXES"

   If  ZLINK  finds  taxes.m  or  TAXES.o,  the  command  adds  the   routine
   TAXES  to  the  current  image.  When  ZLINK  cannot  locate  TAXES.o,  or
   when it  finds  TAXES.o  is  older  than  TAXES.m,  it  compiles  TAXES.m,
   producing a  new  TAXES.o,  and  adds  the  contents  of  the  new  object
   file to  the  image.  For  more  information  on  ZLINK  operation,  refer
   to the "Commands" chapter in the GT.M Programmer's Guide.

   When the intrinsic special  variable  $zroutines  is  not  null,  a  ZLINK
   command that does not  specify  a  directory  uses  $zroutines  to  locate
   files.  When  $zroutines  is  null,  ZLINK  uses  the  current  directory.
   For more information  on  $zroutines,  refer  to  the  "Intrinsic  Special
   Variables" chapter in the GT.M Programmer's Guide.

   When  the  file  name  includes  an  explicit  directory,  ZLINK  searches
   only that directory. If  you  specify  a  ZLINK  with  a  directory  other
   than  your  default  and  with  no  file  extension,  GT.M  searches   for
   both the object and the source  in  the  named  directory.  If  a  compile
   is  required,  ZLINK  places  the  new  object   file   in   the   default
   directory.   A   ZLINK   repeated   under    these    conditions    always
   recompiles,  since  GT.M  will  never  find  the  object   file   in   the
   specified  directory,   and   adds   object   modules   to   the   default
   directory.  To  avoid  this,  move  the  object  module   to   the   named
   directory,   or   set   $zroutines   to   the   named   directory   before
   ZLINKing.

   Auto-ZLINK uses  the  same  method  for  locating  and  selecting  a  file
   as  does  an  explicit  ZLINK  without  a  specified  directory  and  file
   extension.

   ZLINK cannot change  a  currently  active  routine,  that  is,  a  routine
   displayed  in  a  ZSHOW  "S"  of  the  stack.  ZLINK  a  currently  active
   routine by first  removing  it  from  the  MUMPS  stack,  using  a  ZGOTO,
   or one or more QUITs.

   To maintain compatibility with  other  editions  of  GT.M,  which  do  not
   permit the percent sign in a  file  name,  if  the  name  of  the  routine
   to ZLINK  begins  with  a  percent  (%)  sign,  GT.M  uses  an  underscore
   (_) in place of the percent in the file name.

   Example

   GTM>ZLINK "_MGR"

   This ZLINK links the MUMPS routine %MGR into the current image.

1 ZMESSAGE
  ZMessage
   The ZM[ESSAGE] command signals a specified condition.

   The format of the ZMESSAGE command is:

   ZM[ESSAGE][:tvexpr] intexpr{[:expr...][,...]\}

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The required integer expression  specifies  the  exception  condition
        to signal

2 Examples
  ZMessage Examples
   All of the following examples issue  ZMESSAGE  from  Direct  Mode  where
   exception conditions do not invoke $ZTRAP.

   Example

   GTM>zm 2
   No such file or directory

   This ZMESSAGE  does  not  specify  substitution  text  and  the  message
   does not include any substitution directives.

   Example

   GTM>zm 150372994
   Global Variable undefined:

   The  message   specified   by   this   ZMESSAGE   command   includes   a
   substitution directive but the command does not supply any text.

   Example

   GTM>zm 150372994:"^GNAME"
   %GTM-E-GVUNDEF, Global Variable undefined:  ^GNAME

   This  ZMESSAGE  command  supplies  the   substitution   text   for   the
   message.

   UNIX treats odd conditions  as  "successful."  GT.M  handles  successful
   conditions  by  displaying  the  associated   message   and   continuing
   execution.  UNIX  treats  even  conditions  as  failures.  GT.M  handles
   failure conditions by storing the  error  information  in  $ZSTATUS  and
   XECUTEing $ZTRAP  or  by  terminating  if  $ZTRAP="".  In  Direct  Mode,
   GT.M only  reports  failure  conditions  to  the  principal  device  and
   does not  XECUTE  $ZTRAP  or  set  $ZSTATUS.  For  more  information  on
   error  handling,  refer  to  the  "Processing  Errors"  chapter  of  the
   GT.M Programmer's Guide.

1 ZPRINT
  ZPrint
   The  ZPRINT  command  displays  source  code   lines   selected   by   its
   argument.

   The format of the ZPRINT command is:

   ZP[RINT][:tvexpr] [entryref[:label[+intexpr]][,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    A ZPRINT with no argument  prints  the  entire  current  routine;  in
        this case, at least  two  (2)  spaces  must  follow  the  command  to
        separate it from the next command on the line

   o    The optional entryref specifies the location to start printing;    if
        the entryref does not contain  a  routinename,  ZPRINT  defaults  the
        routine to the current routine;  the current routine is  the  routine
        closest to the top of a ZSHOW "S"

   o    The optional label specifies a label at which to stop  printing;  the
        optional integer expression specifies an offset from  the  label;  if
        the entryref does not specify a  label,  the  integer  expression  is
        taken as an offset from the beginning of the routine; the  label  and
        offset  together  are  referred  to  as  a  lineref;   this   lineref
        specifies the location of the last line to print

   o    If the ZPRINT argument includes the colon  (:)  delimiter,  then  the
        argument must also include at least one  component  of  the  optional
        lineref

   o    If the ZPRINT argument does not contain  the  optional  lineref,  the
        entryref completely controls the ZPRINT:  if  the  entryref  contains
        lineref information, ZPRINT  displays  only  one  line,  and  if  the
        entryref contains only a  routinename,  ZPRINT  displays  the  entire
        routine

   o    If  the  entryref  contains  only  a  routinename  and  the  argument
        includes the optional lineref,  ZPRINT  starts  the  display  at  the
        beginning of the routine

   o    If the optional  lineref  specifies  a  line  prior  to  the  lineref
        specified within the entryref, ZPRINT does not display any lines

   o    If the offset in the optional lineref specifies  a  line  beyond  the
        end of the routine, ZPRINT displays the remainder of the routine

   o    If ZPRINT cannot locate the routine or, if either of  the  labels  do
        not appear in the routine, ZPRINT issues an error

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more ZPRINT arguments form a legal argument for a ZPRINT

   Note  that  the  routinename  may  only  appear  before  the   colon   (:)
   delimiter. The integer expression offsets may  be  positive  or  negative,
   however, they must always be delimited by a plus-sign (+).

   For more  information  on  entryrefs,  refer  to  the  "General  Features"
   chapter in the GT.M Programmer's Guide.

2 Examples
  ZPrint Examples

   Example

   GTM>ZPRINT X^RTN

   This example displays the  line  beginning  with  the  label  X  in  the
   routine RTN.

   Example

   GTM> ZPRINT X^RTN:X+5
   GTM> ZPRINT X+-5^RTN:X
   GTM> ZPRINT X^RTN:X-5^RTN

   The first line displays the line beginning with  the  label  X  and  the
   next 5 lines in routine RTN.  The  second  line  displays  the  5  lines
   preceding label X in the  same  routine  and  the  line  beginning  with
   label X. The third line generates a run-time error.

1 ZSHOW
  ZShow
   The  ZSHOW  command  displays  information   about   the   current   MUMPS
   environment.

   The format of the ZSHOW command is:

   ZSH[OW][:tvexpr] [expr[:glvn][,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional expression specifies one or more codes  determining  the
        nature of the information displayed

   o    A ZSHOW with no argument defaults to ZSHOW "S";   in  this  case,  at
        least two (2) spaces must follow the ZSHOW to separate  it  from  the
        next command on the line

   o    The  optional  global  or   local   variable   name   specifies   the
        destination for the ZSHOW output

   o    If the ZSHOW argument does not contain a  global  or  local  variable
        name, ZSHOW directs its display to the current device ($IO)

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more ZSHOW arguments form a legal argument for a ZSHOW

2 Codes
  ZShow Information Codes
   A ZSHOW argument is an expression  containing  codes  selecting  one  or
   more types of information.

   B     displays active ZBREAK breakpoints

   D     displays device information

   I     displays the current values of all intrinsic special variables

   L     displays MUMPS LOCKs and ZALLOCATEs held by the process

   S     displays the MUMPS stack

   V     displays local variables

   *     displays all possible types of ZSHOW information

   Codes may be upper- or lower-case.  Invalid  codes  produce  a  run-time
   error. Multiple occurrences of the  same  code  in  one  ZSHOW  argument
   only  produce  one  output  of  the  corresponding   information.   When
   ZSHOW  displays  rather  than  stores  its  output,  the  order  of  the
   first appearance of the codes  in  the  argument  determines  the  order
   of the corresponding outputs.

2 Order
  ZSHOW Default Order

   If the  wildcard  (*)  occurs  in  the  list,  ZSHOW  uses  the  default
   order:

   o     Intrinsic special variables

   o     local variables

   o     ZBREAK information

   o     device information

   o     LOCK and ZALLOCATE information

   o     the MUMPS stack

2 Examples
  ZShow Examples

   Example

   GTM>ZSHOW "db"

   This command  displays  all  devices  with  deviceparameters  reflecting
   their  current  characteristics   followed   by   any   current   ZBREAK
   locations with their corresponding actions.

   Example

   GTM>ZSHOW "DBD"

   This command displays the same output as the previous example.

   Example

   GTM>ZSHOW "ax"

   This command generates a run-time error.

   Example

   LAB1   DO LAB2
          QUIT
   LAB2   DO LAB3
          QUIT
   LAB3   ZSHOW
          QUIT

   Produces the results:

   LAB3^RTN
   LAB2^RTN
   LAB1^RTN

2 Destination_Variables
  ZShow Destination Variables
   ZSHOW may specify  an  unsubscripted  or  subscripted  global  or  local
   variable name  (glvn)  into  which  ZSHOW  places  its  output.  If  the
   argument does not  include  a  global  or  local  variable  name,  ZSHOW
   directs its output  to  the  current  device.  When  ZSHOW  directs  its
   output to a  variable,  it  adds  two  levels  of  descendants  to  that
   variable. The first level  subscript  contains  a  one-character  string
   from the set of upper-case ZSHOW  action  codes,  identifying  the  type
   of information. ZSHOW implicitly KILLs  all  descendants  of  the  first
   level nodes. ZSHOW stores  information  elements  at  the  second  level
   using ascending integers, starting  at  1.  When  a  ZSHOW  "V"  directs
   its output to a local variable (lvn), the  result  does  not  contain  a
   copy of the descendants of the resulting "V" node.

3 Examples
  ZShow Destination Examples

   Example

   GTM>K  S b(1,"two")="test" ZSHOW "v":a ZWR
   a("V",1)="b(1,""two"")=""test"""
   b(1,"two")="test"

   GTM>

   This ZSHOW stores all local  variables  in  the  local  variable  "a".
   Note that ZSHOW does not replicate a("V") and a("V",1).

   Example

   GTM>K  S a(1,"D",3,5)="stuff",a(1,"X",2)="",a(1)=1
   GTM>ZSH "d":a(1)
   GTM>ZWRITE
   a(1)=1
   a(1,"D",1)="TERMINAL 0 EDI ... LEN=24 "
   a(1,"D",2)="TERMINAL     SYS$INPUT     EDI      ...      LEN=24      "
   a(1,"D",3)="TERMINAL     SYS$OUTPUT     EDI     ...      LEN=24      "
   a(1,"X",2)=""

   GTM>

   This  ZSHOW  stores  the  current  open   device   information   under
   a(1).  The  ellipses  (...)  have  been   used   in   the   place   of
   additional   deviceparameters   for   readability   and    typesetting
   reasons. Notice how the ZSHOW deletes a(1,"D",3,5).

   Example

   GTM>K ^ZSHOW
   GTM>ZB -*,lab^rout ZSH "B":^ZSHOW
   GTM>ZWR ^ZSHOW
   ^ZSHOW("B",1)="LAB^ROUT:""B"""

   GTM>

   This  ZSHOW  stores  the  current   ZBREAK   information   under   the
   global variable ^ZSHOW.

2 Useage
  Use of ZShow
   Use ZSHOW for the following:

   o     As a debugging tool to display information on the environment

   o     As an error-handling tool to  capture  context  information  after
         an unpredictable error with output directed to a  sequential  file
         or a global

   o     As part of a  context-switching  mechanism  in  a  server  program
         that must manage multiple contexts

   To avoid confusing  data  interactions,  avoid  directing  ZSHOW  output
   into  variables  holding  other   kinds   of   information   and   avoid
   directing ZSHOW "V"  output  into  local  variables.  For  a  comparison
   of  ZSHOW  "V"  and  ZWRITE,  refer  to  the  ZWRITE  section   in   the
   "Commands" chapter in the GT.M Programmer's Guide.

1 ZSTEP
  ZSTEP
   The ZSTEP command provides the ability to  control  GT.M  execution.  When
   a  ZSTEP  is  issued  from  Direct  Mode,  execution  continues   to   the
   beginning of the  next  target  line  and  then  GT.M  XECUTEs  the  ZSTEP
   action.  The  keyword  in  the  optional  ZSTEP  argument  determines  the
   class of eligible target lines.

   The format of the ZSTEP command is:

   ZST[EP][:tvexpr] [keyword[:expr]][,...]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional keyword specifies the nature of the step;  the  keywords
        are INTO, OVER and OUTOF

   o    A ZSTEP with no argument performs the default action  OVER;  in  this
        case, at least two (2) spaces must follow the ZSTEP  to  separate  it
        from the next command on the line

   o    The optional expression specifies  MUMPS  code  to  XECUTE  when  the
        ZSTEP arrives at its destination

   o    If the ZSTEP  argument  does  not  contain  an  expression  argument,
        ZSTEP defaults the action to "BREAK"

   Note that the ZSTEP argument keywords are  NOT  expressions.  Unlike  most
   MUMPS commands, ZSTEP does not accept argument indirection.

   In Direct  Mode,  ZSTEP  performs  an  implicit  ZCONTINUE  and  therefore
   GT.M ignores all commands on the command line after the ZSTEP.

   The  keyword  arguments  define  the  class  of  lines  where  ZSTEP  next
   pauses execution to XECUTE the ZSTEP action.  When  a  ZSTEP  command  has
   multiple arguments, it ignores all arguments except the last.

2 INTO
  ZStep INTO
   ZSTEP INTO pauses at the beginning  of  the  next  line,  regardless  of
   transfers  of  control.  When  the   ZSTEPped   line   invokes   another
   routine or a subroutine  in  the  current  routine,  ZSTEP  INTO  pauses
   at  the  first  line  of  code  associated  with  the  new  MUMPS  stack
   level.

2 OUTOF
  ZSTEP OUTOF
   ZSTEP OUTOF pauses at the beginning of  the  next  line  executed  after
   an explicit or implicit  QUIT  from  the  current  MUMPS  virtual  stack
   level. A ZSTEP OUTOF  does  not  pause  at  lines  associated  with  the
   current MUMPS stack level  or  with  levels  invoked  from  the  current
   level.

2 OVER
  ZSTEP OVER
   ZSTEP OVER pauses at  the  beginning  of  the  next  line  in  the  code
   associated with either the current  MUMPS  stack  level  or  a  previous
   MUMPS  stack  level  if  the  ZSTEPped  line  contains  an  explicit  or
   implicit QUIT from the current  level.  A  ZSTEP  OVER  does  not  pause
   at  lines  invoked  from  the  current   line   by   DOs,   XECUTEs   or
   extrinsics.

2 Actions
  ZSTEP Actions
   The optional action parameter of a  ZSTEP  must  contain  an  expression
   evaluating to  valid  GT.M  MUMPS  code.  By  default,  ZSTEP  specifies
   the  action  of  "BREAK"  and  enters  Direct   Mode.   When   a   ZSTEP
   specifies an action, the process  does  not  enter  Direct  Mode  unless
   the action explicitly includes a BREAK command.

2 Interactions
  ZSTEP Interactions
   ZSTEP currently interacts  with  certain  other  elements  in  the  GT.M
   environment.

   o     If a <CTRL C> or a CTRAP character arrives at  certain  points  in
         ZSTEP processing, there is a small  chance  GT.M  may  ignore  the
         <CTRL C> or CTRAP; in a later release, <CTRL C>  and  CTRAPs  will
         always be given priority over ZSTEP

   o     If GT.CM reports  an  asynchronous  network  error,  a  ZSTEP  may
         cause the network error to go unreported; the chance  of  such  an
         occurrence is small and the chance the  error  would  subsequently
         be reported is high; in  a  later  release,  network  errors  will
         always be given priority over ZSTEP

2 Usage
  Use of ZSTEP
   Use ZSTEP to incrementally execute a  routine  or  series  of  routines.
   Execute any GT.M MUMPS command from Direct  Mode  at  any  ZSTEP  pause.
   To  resume  normal   execution,   use   ZCONTINUE.   Note   that   ZSTEP
   arguments are keywords  rather  than  expressions.  They  do  not  allow
   indirection,  and  arguments  lists  have  no  utility.  ZSTEP   actions
   that  include  commands  followed  by  a  BREAK  perform   some   action
   before entering Direct  Mode.  ZSTEP  actions  that  do  not  include  a
   BREAK perform the command action and  continue  execution.    Use  ZSTEP
   actions that issue  conditional  BREAKs  and  subsequent  ZSTEPs  to  do
   such things as test for changes in the value of a variable.

2 Examples
  ZSTEP Examples

   Example

   GTM> ZSTEP INTO:"W ! ZP @$ZPOS W !"

   This  ZSTEP  resumes  execution  of  the   current   routine.   At   the
   beginning of the next  line  executed,  the  ZSTEP  action  ZPRINTs  the
   source code for  that  line.  Because  the  specified  action  does  not
   contain a BREAK command,  execution  continues  to  the  next  line  and
   all subsequent lines in the program flow.

   Example

   GTM>S curx=$g(x),zact="ZST:curx=$g(x) I:zact B:curx'=$g(x)"
   GTM>ZSTEP INTO:zact

   This sequence uses ZSTEP to invoke  Direct  Mode  at  the  beginning  of
   the first line after the line that alters the value of x.

1 ZSYSTEM
  ZSYstem
   The ZSYSTEM command creates a child of the current process.

   The format of the ZSYSTEM command is:

   ZSY[STEM][:tvexpr] [expr[:tvexpr][,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional expression specifies the command passed  to  the  shell;
        after processing the command, the shell returns control to GT.M

   o    If ZSYSTEM has no argument or expr="", the shell  prompts  for  input
        until provided with a logout command; at least two  (2)  spaces  must
        follow a ZSYSTEM command with no argument to  separate  it  from  the
        next command on the line

   o    The  optional  truth-valued   expression   following   the   argument
        expression  specifies  the  argument  postconditional  and   controls
        whether ZSYSTEM processes that argument

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or  more  ZSYSTEM  arguments  form  a  legal  argument  for  a
        ZSYSTEM

   The ZSYSTEM command creates a new  process  and  passes  its  argument  to
   the  shell  for  execution.  The  new  process  executes   in   the   same
   directory as  the  initiating  process.  The  new  process  has  the  same
   operating  system  environment,  such   as   environment   variables   and
   input/output  devices,  as  the   initiating   process.   The   initiating
   process  pauses  until  the  new  process  completes   before   continuing
   execution. The return status  of  the  spawned  process  is  reflected  in
   $ZSYSTEM.

   If a ZSYSTEM command has multiple  arguments,  it  starts  a  new  process
   for  each  argument,  one  at  a  time.  ZSYSTEM  waits  for  one  job  to
   complete before starting the next one.

   A ZSYSTEM with  a  null  argument  causes  the  shell  to  prompt  on  the
   standard out device, and accept commands  from  the  standard  in  device,
   until it receives a logout command  or  other  input  terminator.  For  an
   interactive  process,  both  the  standard  in  and   standard   out   are
   generally  the  user's  terminal.  A  ZSYSTEM   with   no   arguments   is
   equivalent to a ZSYSTEM with a single null string argument.

   If  a  command  postconditional  is  false,  GT.M  does  not  process  the
   ZSYSTEM command. If  an  argument  postconditional  is  false,  GT.M  does
   not process that argument.

2 Examples
  ZSYSTEM Examples

   Example

   GTM> ZSYSTEM "DIR *.m."

   This  uses  ZSYSTEM  to  fork  a  process  that  then  performs  the  ls
   command    to  list  the  current  versions  of  all   files   with   an
   extension of .m, the default extension for    GT.M  source  files.  Once
   the command completes, the forked process terminates.

   Example

   GTM> ZSYSTEM
   $

   This  ZSYSTEM  has  no  argument  so  the  forked  process  prompts  for
   input.

1 ZTCOMMIT
  ZTCommit
   The ZTCOMMIT command marks the end  of  a  logical  transaction  within  a
   MUMPS program. ZTCOMMIT used with  ZTSTART  "fences"  transactions  (i.e.,
   marks the end  and  beginning).  Fencing  transactions  allows  the  MUPIP
   JOURNAL  facility   to   prevent   incomplete   application   transactions
   consisting of multiple global updates from affecting the database.

   The format of the ZTCOMMIT command is:

   ZTC[OMMIT][:tvexpr] [intexpr]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional integer expression specifies  the  number  of  currently
        open ZTSTARTs for the ZTCOMMIT to close

   o    A ZTCOMMIT with no argument closes one ZTSTART;   in  this  case,  at
        least two (2) spaces must follow the  command  to  separate  it  from
        the next command on the line

   o    If the ZTCOMMIT has an argument of 0, it closes all open ZTSTARTs

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more  ZTCOMMIT  arguments  form  a  legal  argument  for  a
        ZTCOMMIT

   When an  application  requires  sub-transactions,  it  may  nest  ZTSTARTs
   and ZTCOMMITs to an arbitrary depth.  However,  a  ZTCOMMIT  must  "close"
   the  outer-most  ZTSTART  before  journaling  accepts  any  part  of   the
   "transaction" as complete.

2 Examples
  ZTCOMMIT Examples

   Example

   GTM> ZTCOMMIT 0

   This  ZTCOMMIT  issued  from  Direct   Mode   would   close   any   open
   ZTSTARTs.

   Example
   
      ____ZTSTART
      |
      | __ZTSTART
      | |
      | |_ZTCOMMIT
      |
      | __ZTSTART
      | |
      | |_ZTCOMMIT
      |
      |___ZTCOMMIT
   
   This   shows    a    transaction    with    two    independent    nested
   sub-transactions.

1 ZTSTART
  ZTStart
   The  ZTSTART  command  marks  the  beginning  of  a  logical   transaction
   within  a  MUMPS  program.  ZTSTART  and  ZTCOMMIT  "fence"   transactions
   (i.e., mark the beginning  and  end).  Fenced  transactions  restrict  the
   MUPIP  JOURNAL  facility  from  recovering  incomplete  transactions.  All
   ZTSTARTs must be matched with  ZTCOMMITs  before  the  journal  processing
   facility recognizes the transaction as complete.

   The format of the ZTSTART command is:

   ZTS[TART][:tvexpr]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    Because ZTSTART has  no  argument,  at  least  two  (2)  spaces  must
        follow the command to separate it from the next command on  the  line
   

   For more information on  Journaling  and  transaction  fencing,  refer  to
   the  section  on  ZTCOMMIT  and  the  "Journaling"  chapter  in  the  GT.M
   Administration and Operations Guide.

2 Examples
  ZTSTART Examples

   Example

          LOCK ^PNT(pnt)
          ZTSTART
          S ^PNT(pnt)=prec,(s,^($H)=$G(^PNT(pnt,+$H))+1,^(+$H,s)=hrec
          ZTCOMMIT
          LOCK

   This uses a LOCK  on  ^*^PNT(pnt)  to  serialize  the  transaction.  The
   logical transaction consists of three  global  sets  that  are  enclosed
   within a ZTSTART and a ZTCOMMIT.

   Example

   BASE   DO WORK
          QUIT

   GRP    LOCK ^FAM(prn)
          SET b=^FAM(prn)
          ZTSTART
          FOR i=1:1:$L(b,"|") D GET,WORK
          ZTCOMMIT
          LOCK
          QUIT

   WORK   LOCK +^ACT(acct)
          ZTSTART
          SET ^ACT(acct)=actrec
   SET ^ACTX(lname,fname,acct)=""
          ZTCOMMIT
          LOCK -^ACT(acct)

   This has a  sub-routine  WORK,  which  BASE  invokes  directly  and  GRP
   invokes to perform a sub-transaction.

1 ZWITHDRAW
  ZWIthdraw
   The ZWITHDRAW command KILLS the data value for  a  variable  name  without
   affecting the nodes descended from that node.

   The format of the ZWITHDRAW command is:

   ZWI[THDRAW][:tvexpr] glvn

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The global or local variable name identifies the variable  for  which
        ZWITHDRAW removes the data value

   o    An indirection operator and an expression atom evaluating to  a  list
        of one  or more ZWITHDRAW arguments  form  a  legal  argument  for  a
        ZWITHDRAW

   ZWITHDRAW provides a tool to quickly restore  a  node  to  a  state  where
   it has descendants and no value - that  is,  where  $DATA  for  that  node
   will have a value of 10 - for  the  case  where  such  a  state  has  some
   control meaning.

2 Example
  ZWITHDRAW Example

   Example

          K A
          SET A="A",A(1)=1,A(1,1)=1
          W $D(A(1)),!
          ZWITHDRAW A(1)
          W $D(A(1)),!
          ZWRITE A
          Q

   produces the result:

   11
   10
   A="A"
   A(1,1)=1

   This sets up local variables A and A(1)  and  A(1,1).  It  then  deletes
   the  data  for  A(1)  with   ZWITHDRAW.   The   ZWRITE   command   shows
   ZWITHDRAW killed A(1) but left A and A(1,1).

1 ZWRITE
  ZWRite
   The ZWRITE command displays the current value of  one  or  more  local  or
   global variables. ZWRITE formats its output  so  that  each  item  in  the
   display forms a valid argument to a  SET  @  command.  This  means  ZWRITE
   encloses string values in  quotes  and  represents  non-graphic  (control)
   characters in $CHAR() syntax.

   The format of the ZWRITE command is:

   ZW[RITE][:tvexpr] [zwrglvn[,...]]

   o    The  optional  truth-valued  expression  immediately  following   the
        command is a  command  postconditional  that  controls  whether  GT.M
        executes the command or not

   o    The optional global or local variable  name  specifies  the  variable
        for ZWRITE to display

   o    ZWRITE accepts a range syntax in place  of  subscripts;  ZWRITE  also
        accepts arguments specifying naked  references  to  globals.  Because
        ZWRITE is primarily a debugging tool,  ZWRITE  does  not  affect  the
        naked indicator

   o    ZWRITE accepts null subscripts  in  its  arguments,  when  these  are
        allowed, and reports array nodes that have null subscripts

   o    A ZWRITE with no  arguments  displays  all  the  currently  available
        local variables; in this case, at least two (2)  spaces  must  follow
        the command to separate it from the next command on the line

   o    If the  global  or  local  variable  name  is  unsubscripted,  ZWRITE
        displays the unsubscripted variable and all subscripted descendants

   o    If an asterisk (*) appears in the  space  normally  occupied  by  the
        last subscript in a subscripted variable name,  ZWRITE  displays  all
        variable nodes descended from the previously specified subscripts

   o    ZWRITE accepts MUMPS pattern-match syntax in place of  both  variable
        names and subscripts

   o    A colon acts as a  range  operator  for  subscript  values;    ZWRITE
        displays all subscripts of the variable starting with  the  value  on
        the left side of the colon and ending with the  value  on  the  right
        side of the colon; if the range delimiter  has  no  left-hand  value,
        the display begins at the first subscript;  if  the  range  delimiter
        has no right-hand value, the display ends at the  last  subscript  at
        that level; if the range delimiter has  no  values  on  either  side,
        ZWRITE displays all subscripts at  that  level;  an  empty  subscript
        level also displays all subscripts at that level

   o    An indirection operator and an expression atom evaluating to  a  list
        of one or more ZWRITE arguments form a legal argument for a ZWRITE

2 Examples
  ZWRITE Examples

   Example

   GTM>ZWR ^1"%"2U(0:":",)

   This command displays  the  descendants  of  all  subscripts  between  0
   and ":" of  all  global  names  starting  with  a  "%"  and  having  two
   upper case letters. (e.g. "%AB")

   Example

   GTM>ZWR A(,:,3)

   This command displays all of the third  level  nodes  with  a  subscript
   of 3 for local variable A.

   Example

      ZWRITE ?1"A".E(1"X"3N)

   This would display data for  any  local  variables  starting  with  "A",
   optionally  followed  by  any  characters,  and  having  any  subscripts
   starting with "X" followed by three numerics.
